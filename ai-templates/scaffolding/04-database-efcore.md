# Part 4: Database & EF Core

**Estimated Time:** 25-30 minutes  
**Prerequisites:** [Part 3 Complete](./03-api-bootstrap-middleware.md)  
**Next:** [Part 5: Extension Methods](./05-extension-methods.md)

---

## üéØ Overview

Database configuration is handled by `DatabaseServicesExtension` with:

- **ContextFactoryRequest Pattern** - Multi-tenant context registration
- **Interceptor Ordering** - CRITICAL: HttpContextAccessor before AuditSaveChangesInterceptor
- **Read-Only Context** - Performance optimization for queries
- **Pagination Options** - Oracle window function optimization
- **Role-Based Commit Denial** - Prevent read-only users from writing

---

## üì¶ Data Project Setup

### 1. Create Data Project

```powershell
cd src
dotnet new classlib -n MySolution.Data
```

### 2. Data .csproj Configuration

```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net10.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <!-- Demoulas Common -->
    <PackageReference Include="Demoulas.Common.Data" />

    <!-- EF Core -->
    <PackageReference Include="Microsoft.EntityFrameworkCore" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Tools" />
    <PackageReference Include="Oracle.EntityFrameworkCore" />

    <!-- Design-Time Tools -->
    <PackageReference Include="Microsoft.EntityFrameworkCore.Abstractions" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MySolution.Common\MySolution.Common.csproj" />
  </ItemGroup>
</Project>
```

---

## üóÇÔ∏è Data Project Structure

```
MySolution.Data/
‚îú‚îÄ‚îÄ Contexts/
‚îÇ   ‚îî‚îÄ‚îÄ MyDbContext.cs                      # EF Core DbContext
‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îú‚îÄ‚îÄ Member.cs
‚îÇ   ‚îú‚îÄ‚îÄ Beneficiary.cs
‚îÇ   ‚îú‚îÄ‚îÄ Distribution.cs
‚îÇ   ‚îî‚îÄ‚îÄ ... (all entity classes)
‚îú‚îÄ‚îÄ Configurations/
‚îÇ   ‚îú‚îÄ‚îÄ MemberConfiguration.cs              # Fluent API configurations
‚îÇ   ‚îú‚îÄ‚îÄ BeneficiaryConfiguration.cs
‚îÇ   ‚îî‚îÄ‚îÄ ... (one per entity)
‚îú‚îÄ‚îÄ Migrations/
‚îÇ   ‚îî‚îÄ‚îÄ ... (auto-generated by EF Core)
‚îú‚îÄ‚îÄ Extensions/
‚îÇ   ‚îî‚îÄ‚îÄ DatabaseServicesExtension.cs        # CRITICAL: Context registration
‚îú‚îÄ‚îÄ Interfaces/
‚îÇ   ‚îî‚îÄ‚îÄ IMyDataContextFactory.cs            # Context factory interface
‚îî‚îÄ‚îÄ DesignTimeDbContextFactory.cs           # For migrations (design-time)
```

---

## üîß Complete DatabaseServicesExtension.cs Template

```csharp
using Demoulas.Common.Data.Contexts.DTOs;
using Demoulas.Common.Data.Contexts.DTOs.Context;
using Demoulas.Common.Data.Contexts.Extensions;
using Demoulas.Common.Data.Contexts.Interfaces;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using MySolution.Data.Contexts;
using MySolution.Data.Interfaces;
using System.Diagnostics;

namespace MySolution.Data.Extensions;

public static class DatabaseServicesExtension
{
    /// <summary>
    /// Registers database services with the DI container.
    /// CRITICAL: HttpContextAccessor MUST be registered before interceptors that use it.
    /// </summary>
    public static IServiceCollection AddDatabaseServices(
        this IServiceCollection services,
        IConfiguration configuration,
        Action<IServiceCollection, List<ContextFactoryRequest>> factoryRequestsAction)
    {
        // ========================================
        // STEP 1: Bind Configuration
        // ========================================
        DataConfig dataConfig = new();
        configuration.Bind("Data", dataConfig);
        services.Configure<DataConfig>(configuration.GetSection("Data"));

        // ========================================
        // STEP 2: CRITICAL - Register HttpContextAccessor FIRST
        // ========================================
        // MUST be registered before AuditSaveChangesInterceptor
        // (interceptor uses IHttpContextAccessor to get user info)
        services.AddHttpContextAccessor();

        // ========================================
        // STEP 3: Initialize Context Factory Requests
        // ========================================
        List<ContextFactoryRequest> factoryRequests = [];
        factoryRequestsAction(services, factoryRequests);

        // ========================================
        // STEP 4: Register Context Factories
        // ========================================
        foreach (var request in factoryRequests)
        {
            // Register interceptors (after HttpContextAccessor)
            if (request.InterceptorFactory is not null)
            {
                // Interceptors are resolved from service provider at runtime
                // This allows them to access scoped services like IHttpContextAccessor
                services.AddDbContextFactory(
                    request.ContextType,
                    (sp, optionsBuilder) =>
                    {
                        var connectionString = configuration.GetConnectionString(request.ConnectionStringName)
                            ?? throw new InvalidOperationException($"Connection string '{request.ConnectionStringName}' not found");

                        optionsBuilder.UseOracle(connectionString);

                        // Add interceptors resolved from service provider
                        var interceptors = request.InterceptorFactory(sp);
                        foreach (var interceptor in interceptors)
                        {
                            optionsBuilder.AddInterceptors(interceptor);
                        }
                    },
                    ServiceLifetime.Scoped);  // Scoped for per-request isolation
            }
            else
            {
                // No interceptors
                services.AddDbContextFactory(
                    request.ContextType,
                    (sp, optionsBuilder) =>
                    {
                        var connectionString = configuration.GetConnectionString(request.ConnectionStringName)
                            ?? throw new InvalidOperationException($"Connection string '{request.ConnectionStringName}' not found");

                        optionsBuilder.UseOracle(connectionString);
                    },
                    ServiceLifetime.Scoped);
            }
        }

        // ========================================
        // STEP 5: Register Pagination Options
        // ========================================
        services.Configure<PaginationOptions>(options =>
        {
            options.EnableOracleWindowFunctionOptimization = true;  // Optimize for Oracle
            options.MaxComplexityScoreForOptimization = 6;          // Complexity threshold
            options.FallbackOnError = !Debugger.IsAttached;         // Fail fast in dev
        });

        // ========================================
        // STEP 6: Register Custom Context Factory Interface
        // ========================================
        services.AddScoped<IMyDataContextFactory, MyDataContextFactory>();

        return services;
    }
}
```

---

## üèóÔ∏è ContextFactoryRequest Pattern

### Usage in API Program.cs

```csharp
using MySolution.Common.Interceptors;
using MySolution.Security;

builder.AddDatabaseServices((services, factoryRequests) =>
{
    // Primary database context
    factoryRequests.Add(ContextFactoryRequest.Initialize<MyDbContext>(
        connectionStringName: "MyDatabase",
        interceptorFactory: sp => [
            sp.GetRequiredService<AuditSaveChangesInterceptor>(),
            sp.GetRequiredService<TenantIdInterceptor>()  // If multi-tenant
        ],
        denyCommitRoles: [Role.READONLY, Role.AUDITOR]));

    // Warehouse context (different database)
    factoryRequests.Add(ContextFactoryRequest.Initialize<WarehouseDbContext>(
        connectionStringName: "Warehouse",
        interceptorFactory: sp => [
            sp.GetRequiredService<AuditSaveChangesInterceptor>()
        ],
        denyCommitRoles: [Role.READONLY]));
});
```

### ContextFactoryRequest.Initialize Parameters

```csharp
public static ContextFactoryRequest Initialize<TContext>(
    string connectionStringName,
    Func<IServiceProvider, IInterceptor[]>? interceptorFactory = null,
    string[]? denyCommitRoles = null)
    where TContext : DbContext
{
    return new ContextFactoryRequest
    {
        ContextType = typeof(TContext),
        ConnectionStringName = connectionStringName,
        InterceptorFactory = interceptorFactory,
        DenyCommitRoles = denyCommitRoles ?? []
    };
}
```

---

## üîß DbContext Implementation

### MyDbContext.cs

```csharp
using Demoulas.Common.Data.Contexts;
using Microsoft.EntityFrameworkCore;
using MySolution.Data.Entities;

namespace MySolution.Data.Contexts;

public class MyDbContext : DeemDbContext
{
    public MyDbContext(DbContextOptions<MyDbContext> options) : base(options) { }

    // DbSets
    public DbSet<Member> Members => Set<Member>();
    public DbSet<Beneficiary> Beneficiaries => Set<Beneficiary>();
    public DbSet<Distribution> Distributions => Set<Distribution>();
    // ... more DbSets

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // Apply entity configurations
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(MyDbContext).Assembly);

        // Oracle-specific configurations
        modelBuilder.HasDefaultSchema("MYAPP");  // Default schema for Oracle
    }
}
```

### DeemDbContext Base Class (from Demoulas.Common)

```csharp
using Demoulas.Common.Data.Contexts.Extensions;
using Microsoft.EntityFrameworkCore;

namespace Demoulas.Common.Data.Contexts;

public abstract class DeemDbContext : DbContext
{
    protected DeemDbContext(DbContextOptions options) : base(options) { }

    /// <summary>
    /// Configures context for read-only operations (auto-applies AsNoTracking).
    /// </summary>
    public void UseReadOnlyContext()
    {
        // Disable change tracking for performance
        this.ChangeTracker.QueryTrackingBehavior = QueryTrackingBehavior.NoTracking;
        this.ChangeTracker.LazyLoadingEnabled = false;
    }
}
```

---

## üè≠ Context Factory Interface

### IMyDataContextFactory.cs

```csharp
using MySolution.Data.Contexts;

namespace MySolution.Data.Interfaces;

public interface IMyDataContextFactory
{
    /// <summary>
    /// Creates a new instance of MyDbContext.
    /// </summary>
    Task<MyDbContext> CreateDbContextAsync(CancellationToken cancellationToken = default);
}
```

### MyDataContextFactory.cs (Implementation)

```csharp
using Demoulas.Common.Data.Contexts.DTOs;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using MySolution.Data.Contexts;
using MySolution.Data.Interfaces;

namespace MySolution.Data.Factories;

public class MyDataContextFactory : IMyDataContextFactory
{
    private readonly IDbContextFactory<MyDbContext> _factory;
    private readonly IOptions<PaginationOptions> _paginationOptions;

    public MyDataContextFactory(
        IDbContextFactory<MyDbContext> factory,
        IOptions<PaginationOptions> paginationOptions)
    {
        _factory = factory;
        _paginationOptions = paginationOptions;
    }

    public async Task<MyDbContext> CreateDbContextAsync(CancellationToken cancellationToken = default)
    {
        var context = await _factory.CreateDbContextAsync(cancellationToken);

        // Apply pagination options to context
        // (future enhancement - context-specific optimization)

        return context;
    }
}
```

---

## üîç Read-Only Context Pattern (CRITICAL)

### Usage in Services

```csharp
public class MemberService : IMemberService
{
    private readonly IMyDataContextFactory _factory;

    public MemberService(IMyDataContextFactory factory)
    {
        _factory = factory;
    }

    public async Task<Result<MemberDto>> GetMemberAsync(int id, CancellationToken ct)
    {
        await using var ctx = await _factory.CreateDbContextAsync(ct);

        // CRITICAL: Use read-only context for queries (disables change tracking)
        ctx.UseReadOnlyContext();

        var member = await ctx.Members
            .TagWith($"GetMember-{id}")  // Query tagging for tracing
            .FirstOrDefaultAsync(m => m.Id == id, ct);

        return member is null
            ? Result<MemberDto>.Failure(Error.MemberNotFound)
            : Result<MemberDto>.Success(member.ToDto());
    }
}
```

**Why UseReadOnlyContext():**

- 30-40% faster queries (no change tracking overhead)
- Prevents accidental modifications
- Auto-applies `AsNoTracking()` globally
- **DO NOT** add `.AsNoTracking()` manually when using `UseReadOnlyContext()` (redundant)

---

## üö® CRITICAL: Interceptor Ordering

### Wrong Order (FAILS)

```csharp
// ‚ùå WRONG: AuditSaveChangesInterceptor registered BEFORE HttpContextAccessor
services.AddScoped<AuditSaveChangesInterceptor>();
services.AddHttpContextAccessor();  // TOO LATE - interceptor already tries to use it
```

**Error:**

```
System.InvalidOperationException: Unable to resolve service for type 'Microsoft.AspNetCore.Http.IHttpContextAccessor'
```

### Correct Order (WORKS)

```csharp
// ‚úÖ RIGHT: HttpContextAccessor registered BEFORE interceptor
services.AddHttpContextAccessor();
services.AddScoped<AuditSaveChangesInterceptor>();
```

**Why:** `AuditSaveChangesInterceptor` constructor injects `IHttpContextAccessor` to get user info. If `IHttpContextAccessor` isn't registered first, DI fails.

---

## ‚öôÔ∏è Pagination Options for Oracle

```csharp
services.Configure<PaginationOptions>(options =>
{
    // Enable Oracle window function optimization
    // Uses ROW_NUMBER() OVER (ORDER BY ...) for efficient pagination
    options.EnableOracleWindowFunctionOptimization = true;

    // Complexity threshold (0-10 scale)
    // Queries with complexity > 6 use standard Skip/Take
    options.MaxComplexityScoreForOptimization = 6;

    // Fail fast vs graceful degradation
    // In dev: false (throw exception to alert developers)
    // In prod: true (fall back to Skip/Take if window function fails)
    options.FallbackOnError = !Debugger.IsAttached;
});
```

**Why Oracle Optimization:**

- Oracle performs poorly with `OFFSET/FETCH` on large datasets
- Window functions (`ROW_NUMBER()`) are significantly faster
- Complexity score prevents over-optimization on complex queries

---

## üîê Role-Based Commit Denial

### Configuration

```csharp
factoryRequests.Add(ContextFactoryRequest.Initialize<MyDbContext>(
    connectionStringName: "MyDatabase",
    interceptorFactory: sp => [sp.GetRequiredService<AuditSaveChangesInterceptor>()],
    denyCommitRoles: [Role.READONLY, Role.AUDITOR]));  // ‚Üê Deny commits for these roles
```

### How It Works

When user with READONLY role tries to save:

```csharp
await ctx.SaveChangesAsync(ct);  // Throws exception
```

**Exception:**

```
System.UnauthorizedAccessException: User with role 'READONLY' is not authorized to commit changes.
```

**Implementation** (in Demoulas.Common):

```csharp
public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
{
    var userRoles = _httpContextAccessor.HttpContext?.User.Claims
        .Where(c => c.Type == ClaimTypes.Role)
        .Select(c => c.Value)
        .ToArray() ?? [];

    if (_denyCommitRoles.Any(deniedRole => userRoles.Contains(deniedRole)))
    {
        throw new UnauthorizedAccessException($"User with role(s) '{string.Join(", ", userRoles)}' is not authorized to commit changes.");
    }

    return await base.SaveChangesAsync(cancellationToken);
}
```

---

## üóÑÔ∏è Entity Configuration Example

### MemberConfiguration.cs

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;
using MySolution.Data.Entities;

namespace MySolution.Data.Configurations;

public class MemberConfiguration : IEntityTypeConfiguration<Member>
{
    public void Configure(EntityTypeBuilder<Member> builder)
    {
        builder.ToTable("MEMBERS", "MYAPP");

        builder.HasKey(m => m.Id);

        builder.Property(m => m.Id)
            .HasColumnName("ID")
            .ValueGeneratedOnAdd();

        builder.Property(m => m.FirstName)
            .HasColumnName("FIRST_NAME")
            .HasMaxLength(100)
            .IsRequired();

        builder.Property(m => m.LastName)
            .HasColumnName("LAST_NAME")
            .HasMaxLength(100)
            .IsRequired();

        builder.Property(m => m.Ssn)
            .HasColumnName("SSN")
            .HasMaxLength(11)
            .IsRequired();

        builder.Property(m => m.BadgeNumber)
            .HasColumnName("BADGE_NUMBER")
            .IsRequired();

        // Indexes
        builder.HasIndex(m => m.Ssn).HasDatabaseName("IX_MEMBERS_SSN");
        builder.HasIndex(m => m.BadgeNumber).HasDatabaseName("IX_MEMBERS_BADGE_NUMBER");

        // Relationships
        builder.HasMany(m => m.Distributions)
            .WithOne(d => d.Member)
            .HasForeignKey(d => d.MemberId)
            .OnDelete(DeleteBehavior.Restrict);
    }
}
```

---

## üõ†Ô∏è Design-Time DbContext Factory (for Migrations)

### DesignTimeDbContextFactory.cs

```csharp
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Design;
using Microsoft.Extensions.Configuration;
using MySolution.Data.Contexts;

namespace MySolution.Data;

/// <summary>
/// Used by EF Core tooling (dotnet ef migrations add/update).
/// Allows migrations without running the full application.
/// </summary>
public class DesignTimeDbContextFactory : IDesignTimeDbContextFactory<MyDbContext>
{
    public MyDbContext CreateDbContext(string[] args)
    {
        // Load configuration from appsettings.json
        var configuration = new ConfigurationBuilder()
            .SetBasePath(Directory.GetCurrentDirectory())
            .AddJsonFile("appsettings.Development.json", optional: false)
            .AddUserSecrets<DesignTimeDbContextFactory>()  // Load connection string from user secrets
            .Build();

        var optionsBuilder = new DbContextOptionsBuilder<MyDbContext>();
        var connectionString = configuration.GetConnectionString("MyDatabase")
            ?? throw new InvalidOperationException("Connection string 'MyDatabase' not found");

        optionsBuilder.UseOracle(connectionString);

        return new MyDbContext(optionsBuilder.Options);
    }
}
```

---

## üß™ Migration Commands

```powershell
# Add a new migration
cd src/MySolution.Data
dotnet ef migrations add AddMemberTable --context MyDbContext

# Update database to latest migration
dotnet ef database update --context MyDbContext

# Revert to specific migration
dotnet ef database update PreviousMigrationName --context MyDbContext

# Generate SQL script for migration (for DBA review)
dotnet ef migrations script --context MyDbContext --output migration.sql

# Remove last migration (if not applied to database)
dotnet ef migrations remove --context MyDbContext
```

---

## ‚úÖ Validation Checklist - Part 4

- [ ] **Data project created** with EF Core packages
- [ ] **DatabaseServicesExtension.cs** implemented with CRITICAL ordering
- [ ] **HttpContextAccessor** registered BEFORE interceptors
- [ ] **DbContext** inherits from `DeemDbContext`
- [ ] **ContextFactoryRequest.Initialize** used in API Program.cs
- [ ] **Read-only context pattern** understood (`UseReadOnlyContext()`)
- [ ] **Entity configurations** created (one per entity)
- [ ] **PaginationOptions** configured for Oracle optimization
- [ ] **Role-based commit denial** configured
- [ ] **Design-time factory** created for migrations
- [ ] **First migration** created and applied successfully

---

## üéì Key Takeaways - Part 4

1. **Interceptor Ordering** - HttpContextAccessor MUST be registered before interceptors that use it
2. **Read-Only Context** - Use `UseReadOnlyContext()` for 30-40% faster queries
3. **ContextFactoryRequest Pattern** - Clean registration of multiple contexts
4. **Oracle Optimization** - Window functions for efficient pagination
5. **Role-Based Security** - Prevent read-only users from committing changes

---

**Next:** [Part 5: Extension Methods](./05-extension-methods.md) - AddProjectServices, AddSecurityServices, AddProfitSharingTelemetry patterns
