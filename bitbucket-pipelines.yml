# ============================================================================
#                        BITBUCKET PIPELINES CONFIGURATION
#                           SMART Profit Sharing Application
# ============================================================================
#
# OVERVIEW
# --------
# This pipeline automates CI/CD for the SMART Profit Sharing application,
# which consists of:
#   - Backend: .NET 10 API with FastEndpoints (src/services/)
#   - Frontend: React/TypeScript UI with Vite (src/ui/)
#
# PIPELINE TYPES
# --------------
# 1. BRANCH PIPELINES (pipelines.branches)
#    - main:    Full build, test, and deploy to QA, then UAT
#    - develop: Selective build/test based on changes since last successful build
#
# 2. PULL REQUEST PIPELINE (pipelines.pull-requests)
#    - Runs on all PRs targeting any branch
#    - Selective testing based on changed files
#    - Uses Bitbucket's changeset conditions for efficiency
#
# 3. CUSTOM PIPELINES (pipelines.custom)
#    - infrastructure_as_code: Install .NET hosting bundle, configure IIS
#    - api_lint: Run API linting
#    - profitsharing_database: Database operations (upgrade, reset, import)
#    - playwright_e2e_qa: End-to-end tests
#
# OPTIMIZATION FEATURES
# ---------------------
# - Selective Testing: Only runs tests for changed areas (frontend/backend)
# - Rolling Tag: Tracks last successful develop build to minimize redundant work
# - Combined Steps: Backend unit + architecture tests share a single build
# - Artifact Reuse: Build artifacts passed between stages
#
# RUNNER CONFIGURATION
# --------------------
# - Windows Self-Hosted: Backend builds, database operations, deployments
# - Cloud (Alpine): Frontend builds, linting (frees on-prem resources)
#
# ENVIRONMENT SERVERS
# -------------------
# - QA:  appt23d
# - UAT: appt24d
#
# REQUIRED REPOSITORY VARIABLES
# -----------------------------
# - BITBUCKET_ACCESS_TOKEN: For tag updates via REST API
# - JFROG_WORKSPACE_VARIABLE: NPM registry authentication
# - ConnectionStrings_ProfitSharing_QA/UAT: Database connections
# - TEAMS_WEBHOOK_URL: Microsoft Teams notifications
# - See repository settings for full list
#
# ============================================================================
#                              TABLE OF CONTENTS
# ============================================================================
#
# DEFINITIONS (line ~60)
# ├── servers:                        Environment server hostnames
# └── steps:                          Reusable step definitions
#     ├── build-and-test-backend      Combined backend build + tests (PR/QA)
#     ├── selective-develop-analysis  Analyze changes for develop branch
#     ├── update-develop-tag          Update rolling success tag
#     ├── selective-backend-analysis  Determine which backend tests to run
#     ├── audit-frontend              NPM vulnerability scan
#     ├── audit-backend               NuGet vulnerability scan
#     ├── secret-scan                 Detect leaked secrets
#     ├── frontend-lint               ESLint + TypeScript check
#     ├── test-frontend               Frontend unit tests (selective for PRs)
#     ├── generate-buildinfo          Create build metadata
#     ├── create-api-artifacts        Package API for deployment
#     ├── create-service-artifacts    Package background services
#     ├── create-frontend-artifact-*  Frontend builds per environment
#     ├── *-drop-recreate-db          Database reset steps
#     ├── *-import-*                  Data import steps
#     └── run-playwright-tests        E2E test execution
#
# PIPELINES (line ~1350)
# ├── branches:
# │   ├── main:                   Full QA + UAT deployment
# │   └── develop:                Selective build/test with tag tracking
# ├── pull-requests:              PR validation with changeset conditions
# └── custom:                     Manual trigger pipelines
#
# ============================================================================

# ============================================================================
#                                 DEFINITIONS
# ============================================================================
# Reusable components referenced throughout the pipeline using YAML anchors.
# Anchors are defined with & and referenced with *.
# ============================================================================

definitions:
  # --------------------------------------------------------------------------
  # SERVER CONFIGURATION
  # --------------------------------------------------------------------------
  # Centralized server hostnames for each environment.
  # Update these when server names change.
  # --------------------------------------------------------------------------
  servers:
    qa_app_server: &qa_app_server "appt23d"
    uat_app_server: &uat_app_server "appt24d"

  # --------------------------------------------------------------------------
  # REUSABLE STEP DEFINITIONS
  # --------------------------------------------------------------------------
  # These steps are referenced by pipelines using YAML anchors (*step-name).
  # Each step is documented with its purpose, runner type, and key behaviors.
  # --------------------------------------------------------------------------
  steps:
    # ========================================================================
    # BACKEND BUILD AND TEST (Combined)
    # ========================================================================
    # Purpose: Build .NET solution and run both unit + architecture tests
    # Runner:  Windows self-hosted (requires .NET 10 SDK)
    # Used by: PR pipeline, QA pipeline
    #
    # Optimization: Single build shared by both test suites
    # Selective:    Reads selective-test-decision.json for PR builds
    # ========================================================================
    build-and-test-backend: &build-and-test-backend
      name: Build and Test Backend API
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          # Set environment variables
          $env:NUGET_ORG = "https://api.nuget.org/v3/index.json"

          # Check selective test decision and set filters
          $testFilters = @()
          $runAllTests = $true
          $skipTests = $false
          $runArchitectureTests = $true

          if ($env:BITBUCKET_PR_DESTINATION_BRANCH -and (Test-Path "selective-test-decision.json")) {
            Write-Host "Checking selective test decision..." -ForegroundColor Cyan
            $decision = Get-Content "selective-test-decision.json" -Raw | ConvertFrom-Json

            if ($decision.decision -eq "SKIP_ALL") {
              Write-Host "SKIP: No backend files changed" -ForegroundColor Yellow
              $skipTests = $true
            }
            elseif ($decision.decision -eq "SELECTIVE" -and $decision.testFilters.Count -eq 0) {
              Write-Host "SKIP: No test filters (only test files changed)" -ForegroundColor Yellow
              $skipTests = $true
            }
            elseif ($decision.decision -eq "SELECTIVE" -and $decision.testFilters.Count -gt 0) {
              $runAllTests = $false
              $testFilters = $decision.testFilters
              Write-Host "SELECTIVE: Running tests for: $($testFilters -join ', ')" -ForegroundColor Green
            }
            else {
              Write-Host "RUN ALL: $($decision.reason)" -ForegroundColor Yellow
            }

            # Check if architecture tests should run
            if ($decision.runArchitectureTests -eq $false) {
              $runArchitectureTests = $false
              Write-Host "Architecture tests: SKIP (no structural changes)" -ForegroundColor Yellow
            }
          }

          if ($skipTests) {
            Write-Host "Exiting - no tests to run" -ForegroundColor Yellow
            exit 0
          }

          # Verify .NET SDK
          $dotnetSdkList = dotnet --list-sdks
          Write-Output "Installed .NET SDKs:"
          Write-Output $dotnetSdkList
          $dotnetSdkRequired = $dotnetSdkList | Select-String "^10\."
          if (-not $dotnetSdkRequired) {
            Write-Error "FAILED: .NET 10 SDK is required but not available."
            exit 1
          }

          # Build once for all tests
          Write-Host "`n========================================" -ForegroundColor Cyan
          Write-Host "Building solution..." -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          dotnet clean src/services/Demoulas.ProfitSharing.slnx --configuration Release
          dotnet restore src/services/Demoulas.ProfitSharing.slnx
          dotnet build src/services/Demoulas.ProfitSharing.slnx --configuration Release --no-incremental --no-restore

          # Run Unit Tests
          Write-Host "`n========================================" -ForegroundColor Cyan
          Write-Host "Running Unit Tests..." -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          $unitTestsPath = "../../../../test-reports/build_${env:BITBUCKET_BUILD_NUMBER}/unit-tests"
          mkdir -Force -Path $unitTestsPath
          $unitTestExe = "src/services/tests/Demoulas.ProfitSharing.UnitTests/bin/Release/net10.0/Demoulas.ProfitSharing.UnitTests.exe"

          if ($runAllTests) {
            Write-Host "Running ALL unit tests" -ForegroundColor Cyan
            & $unitTestExe -jUnit "$unitTestsPath/junit.xml"
          } else {
            Write-Host "Running SELECTIVE tests" -ForegroundColor Green
            Write-Host "Filters: $($testFilters -join ', ')" -ForegroundColor Yellow
            $namespaceArgs = @("-jUnit", "$unitTestsPath/junit.xml")
            foreach ($filter in $testFilters) {
              $namespaceArgs += "-namespace"
              $namespaceArgs += "*$filter*"
            }
            Write-Host "Running: $unitTestExe $($namespaceArgs -join ' ')"
            & $unitTestExe @namespaceArgs
          }
          $unitTestExit = $LASTEXITCODE

          # Run Architecture Tests (if enabled)
          $archTestExit = 0
          if ($runArchitectureTests) {
            Write-Host "`n========================================" -ForegroundColor Cyan
            Write-Host "Running Architecture Tests..." -ForegroundColor Cyan
            Write-Host "========================================" -ForegroundColor Cyan
            $archTestsPath = "../../../../test-reports/build_${env:BITBUCKET_BUILD_NUMBER}/architecture-tests"
            mkdir -Force -Path $archTestsPath
            $archTestExe = "src/services/tests/Demoulas.ProfitSharing.UnitTests.Architecture/bin/Release/net10.0/Demoulas.ProfitSharing.UnitTests.Architecture.exe"
            & $archTestExe -jUnit "$archTestsPath/junit.xml"
            $archTestExit = $LASTEXITCODE
          } else {
            Write-Host "`nArchitecture Tests: SKIPPED" -ForegroundColor Yellow
          }

          # Report results
          Write-Host "`n========================================" -ForegroundColor Cyan
          Write-Host "Test Results Summary" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "Unit Tests: $(if ($unitTestExit -eq 0) { 'PASSED' } else { 'FAILED' })" -ForegroundColor $(if ($unitTestExit -eq 0) { 'Green' } else { 'Red' })
          if ($runArchitectureTests) {
            Write-Host "Architecture Tests: $(if ($archTestExit -eq 0) { 'PASSED' } else { 'FAILED' })" -ForegroundColor $(if ($archTestExit -eq 0) { 'Green' } else { 'Red' })
          } else {
            Write-Host "Architecture Tests: SKIPPED" -ForegroundColor Yellow
          }

          # Exit with failure if any test suite failed
          if ($unitTestExit -ne 0 -or $archTestExit -ne 0) {
            Write-Error "One or more test suites failed"
            exit 1
          }

      artifacts:
        - test-reports/**

    # ========================================================================
    # DEVELOP BRANCH ANALYSIS
    # ========================================================================
    # Purpose: Determine which steps to run based on changes since last success
    # Runner:  Windows self-hosted (needs full git history for tag comparison)
    # Used by: develop branch pipeline only
    #
    # How it works:
    # 1. Compares HEAD against 'last-successful-develop-build' tag
    # 2. Categorizes changed files as frontend (src/ui/) or backend (src/services/)
    # 3. Outputs develop-test-decision.json with runFrontend/runBackend flags
    # 4. Includes list of changed frontend files for selective test targeting
    #
    # Note: Uses depth:full clone because git network operations hang on
    #       Windows runners, so we need all tags available locally.
    # ========================================================================
    selective-develop-analysis: &selective-develop-analysis
      name: Analyze Develop Changes (Since Last Build)
      runs-on:
        - windows
        - self.hosted
      clone:
        depth: full
      artifacts:
        - develop-test-decision.json
      script:
        - |
          $tagName = "last-successful-develop-build"

          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "Analyzing changes since last successful develop build" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan

          # Check if the tag exists locally (included via depth: full clone)
          # Note: We don't check remote because git network ops hang on Windows runners
          Write-Host "Checking for baseline tag..." -ForegroundColor Gray
          $tagExists = git tag -l $tagName

          if (-not $tagExists) {
            Write-Host "Tag '$tagName' not found - this is the first run" -ForegroundColor Yellow
            Write-Host "Will run ALL steps to establish baseline" -ForegroundColor Yellow
            $decision = @{
              runFrontend = $true
              runBackend = $true
              reason = "First run - no baseline tag exists"
              isFirstRun = $true
            } | ConvertTo-Json -Compress
            [System.IO.File]::WriteAllText("develop-test-decision.json", $decision)
            exit 0
          }

          # Get commit info
          $lastBuildCommit = git rev-parse $tagName
          $currentCommit = git rev-parse HEAD

          Write-Host "Last successful build: $lastBuildCommit" -ForegroundColor Cyan
          Write-Host "Current HEAD: $currentCommit" -ForegroundColor Cyan

          if ($lastBuildCommit -eq $currentCommit) {
            Write-Host "No new commits since last successful build" -ForegroundColor Green
            $decision = @{
              runFrontend = $false
              runBackend = $false
              reason = "No changes since last successful build"
              isFirstRun = $false
            } | ConvertTo-Json -Compress
            [System.IO.File]::WriteAllText("develop-test-decision.json", $decision)
            exit 0
          }

          # Get changed files since last successful build
          $changedFiles = git diff --name-only "$tagName..HEAD" 2>&1

          if ($LASTEXITCODE -ne 0) {
            Write-Host "git diff failed: $changedFiles" -ForegroundColor Yellow
            Write-Host "Falling back to running ALL steps" -ForegroundColor Yellow
            $decision = @{
              runFrontend = $true
              runBackend = $true
              reason = "git diff failed - running all steps for safety"
              isFirstRun = $false
            } | ConvertTo-Json -Compress
            [System.IO.File]::WriteAllText("develop-test-decision.json", $decision)
            exit 0
          }

          $changedFiles = $changedFiles -split "`n" | Where-Object { $_ }
          Write-Host "`nFound $($changedFiles.Count) changed files since last build" -ForegroundColor Cyan

          # Categorize changes
          $frontendChanges = $changedFiles | Where-Object { $_ -match "^src/ui/" }
          $backendChanges = $changedFiles | Where-Object { $_ -match "^src/services/" }

          $runFrontend = $frontendChanges.Count -gt 0
          $runBackend = $backendChanges.Count -gt 0

          # Build reason string
          $reasons = @()
          if ($runFrontend) { $reasons += "Frontend: $($frontendChanges.Count) files changed" }
          if ($runBackend) { $reasons += "Backend: $($backendChanges.Count) files changed" }
          if (-not $runFrontend -and -not $runBackend) { $reasons += "No frontend or backend source changes" }

          Write-Host "`n----------------------------------------" -ForegroundColor Cyan
          Write-Host "Decision Summary:" -ForegroundColor Cyan
          Write-Host "----------------------------------------" -ForegroundColor Cyan
          Write-Host "  Run Frontend Steps: $(if ($runFrontend) { 'YES' } else { 'SKIP' })" -ForegroundColor $(if ($runFrontend) { 'Green' } else { 'Yellow' })
          Write-Host "  Run Backend Steps:  $(if ($runBackend) { 'YES' } else { 'SKIP' })" -ForegroundColor $(if ($runBackend) { 'Green' } else { 'Yellow' })
          Write-Host "----------------------------------------" -ForegroundColor Cyan

          if ($frontendChanges.Count -gt 0 -and $frontendChanges.Count -le 20) {
            Write-Host "`nFrontend files changed:" -ForegroundColor Yellow
            $frontendChanges | ForEach-Object { Write-Host "  - $_" }
          }

          if ($backendChanges.Count -gt 0 -and $backendChanges.Count -le 20) {
            Write-Host "`nBackend files changed:" -ForegroundColor Yellow
            $backendChanges | ForEach-Object { Write-Host "  - $_" }
          }

          $decision = @{
            runFrontend = $runFrontend
            runBackend = $runBackend
            reason = ($reasons -join "; ")
            isFirstRun = $false
            frontendFileCount = $frontendChanges.Count
            backendFileCount = $backendChanges.Count
            frontendFiles = @($frontendChanges)
          } | ConvertTo-Json -Compress
          # Use WriteAllText to avoid BOM that Out-File adds
          [System.IO.File]::WriteAllText("develop-test-decision.json", $decision)

    # ========================================================================
    # UPDATE DEVELOP BUILD TAG
    # ========================================================================
    # Purpose: Move the rolling success tag to current commit after all tests pass
    # Runner:  Windows self-hosted
    # Used by: develop branch pipeline (final step)
    #
    # This enables the selective-develop-analysis step to compare against
    # the last successful build on subsequent pipeline runs.
    #
    # Note: Uses Bitbucket REST API instead of git push because git network
    #       operations hang on Windows self-hosted runners.
    # Requires: BITBUCKET_ACCESS_TOKEN with repository:write scope
    # ========================================================================
    update-develop-tag: &update-develop-tag
      name: Update Develop Build Tag
      runs-on:
        - windows
        - self.hosted
      max-time: 5
      script:
        - |
          $tagName = "last-successful-develop-build"
          $currentCommit = git rev-parse HEAD

          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "Updating develop build tag" -ForegroundColor Cyan
          Write-Host "========================================" -ForegroundColor Cyan
          Write-Host "Tag: $tagName" -ForegroundColor Cyan
          Write-Host "Commit: $currentCommit" -ForegroundColor Cyan

          # Use Bitbucket REST API to update tag (avoids git network hanging issues)
          $baseUrl = "https://api.bitbucket.org/2.0/repositories/$env:BITBUCKET_REPO_FULL_NAME/refs/tags"
          $headers = @{
            "Authorization" = "Bearer $env:BITBUCKET_ACCESS_TOKEN"
            "Content-Type" = "application/json"
          }

          # Check if BITBUCKET_ACCESS_TOKEN is available
          if (-not $env:BITBUCKET_ACCESS_TOKEN) {
            Write-Host "[WARNING] BITBUCKET_ACCESS_TOKEN not set - cannot update tag via API" -ForegroundColor Yellow
            Write-Host "Please create a Repository Access Token with repository:write scope." -ForegroundColor Yellow
            exit 0
          }

          try {
            # Delete existing tag if it exists (ignore 404 errors)
            Write-Host "Deleting existing tag (if any)..." -ForegroundColor Gray
            try {
              Invoke-RestMethod -Uri "$baseUrl/$tagName" -Method Delete -Headers $headers -ErrorAction Stop
              Write-Host "  Existing tag deleted" -ForegroundColor Gray
            } catch {
              if ($_.Exception.Response.StatusCode -ne 404) {
                Write-Host "  Note: $($_.Exception.Message)" -ForegroundColor Gray
              }
            }

            # Create new tag at current commit
            Write-Host "Creating tag at commit $currentCommit..." -ForegroundColor Gray
            $body = @{
              name = $tagName
              target = @{
                hash = $currentCommit
              }
            } | ConvertTo-Json

            $response = Invoke-RestMethod -Uri $baseUrl -Method Post -Headers $headers -Body $body -ErrorAction Stop
            Write-Host "`n[OK] Tag '$tagName' updated successfully via API" -ForegroundColor Green

          } catch {
            Write-Host "`n[WARNING] Failed to update tag via API: $($_.Exception.Message)" -ForegroundColor Yellow
            Write-Host "Next build will run all steps." -ForegroundColor Yellow
            # Don't fail the build for tag issues
            exit 0
          }

    # ========================================================================
    # SELECTIVE BACKEND ANALYSIS (PR Builds)
    # ========================================================================
    # Purpose: Determine which backend tests to run based on changed files
    # Runner:  Windows self-hosted
    # Used by: PR pipeline only
    #
    # How it works:
    # 1. Compares HEAD against PR destination branch
    # 2. Detects global config changes (Directory.Build.props, etc.) → run all
    # 3. Maps changed .cs/.csproj files to test namespace filters
    # 4. Outputs selective-test-decision.json with:
    #    - decision: RUN_ALL | SELECTIVE | SKIP_ALL
    #    - testFilters: namespace patterns for selective test runs
    #    - runArchitectureTests: whether architecture tests are needed
    # ========================================================================
    selective-backend-analysis: &selective-backend-analysis
      name: Analyze Backend Changes (Selective Testing)
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - selective-test-decision.json
      script:
        # Only run selective analysis for PR builds
        - |
          if (-not $env:BITBUCKET_PR_DESTINATION_BRANCH) {
            Write-Host "Branch build detected - skipping selective analysis (will run all tests)" -ForegroundColor Yellow
            # Write RUN_ALL decision so downstream steps run all tests
            @{ decision = "RUN_ALL"; reason = "Branch build" } | ConvertTo-Json | Out-File -FilePath "selective-test-decision.json" -Encoding UTF8
            exit 0
          }

        # Get changed files using git diff (no fetch needed - origin refs already available in pipeline clone)
        - |
          Write-Host "Getting changed files..." -ForegroundColor Cyan

          try {
            $targetBranch = $env:BITBUCKET_PR_DESTINATION_BRANCH
            Write-Host "Target branch: origin/$targetBranch"

            # Get changed files directly - no fetch needed in Bitbucket Pipelines
            $changedFiles = git diff --name-only "origin/$targetBranch" HEAD 2>&1

            if ($LASTEXITCODE -ne 0) {
              Write-Host "git diff failed: $changedFiles" -ForegroundColor Yellow
              Write-Host "Falling back to ALL tests" -ForegroundColor Yellow
              @{
                decision = "RUN_ALL"
                reason = "git diff failed"
              } | ConvertTo-Json | Out-File -FilePath "selective-test-decision.json" -Encoding UTF8
              exit 0
            }

            # Convert to array and filter
            $changedFiles = $changedFiles -split "`n" | Where-Object { $_ }
            Write-Host "Found $($changedFiles.Count) changed files" -ForegroundColor Cyan

            # Check for global configuration changes
            $globalChanges = $changedFiles | Where-Object {
              $_ -match "src/services/Directory\.Build\.props" -or
              $_ -match "src/services/Directory\.Packages\.props" -or
              $_ -match "src/services/global\.json" -or
              $_ -match "src/services/\.editorconfig"
            }

            if ($globalChanges) {
              Write-Host "Global configuration changes detected - will run ALL tests" -ForegroundColor Yellow
              Write-Host "Changed global files:"
              $globalChanges | ForEach-Object { Write-Host "  - $_" -ForegroundColor Yellow }
              @{
                decision = "RUN_ALL"
                reason = "Global configuration changes detected"
                globalChanges = @($globalChanges)
              } | ConvertTo-Json | Out-File -FilePath "selective-test-decision.json" -Encoding UTF8
              exit 0
            }

            # Check if any backend files changed
            $backendChanges = $changedFiles | Where-Object { $_ -match "^src/services/.*\.(cs|csproj)$" }

            if (-not $backendChanges) {
              Write-Host "No backend files changed" -ForegroundColor Green
              @{
                decision = "SKIP_ALL"
                reason = "No backend files changed"
                runUnitTests = $false
                runArchitectureTests = $false
              } | ConvertTo-Json | Out-File -FilePath "selective-test-decision.json" -Encoding UTF8
              exit 0
            }

            Write-Host "Backend files changed:" -ForegroundColor Yellow
            $backendChanges | ForEach-Object { Write-Host "  - $_" -ForegroundColor Yellow }

            # Map changed files to test namespace filters
            $testFilters = @()
            $runAllTests = $false

            foreach ($file in $backendChanges) {
              $file = $file -replace '\\', '/'

              # Skip test files - they don't affect which tests to run
              if ($file -match "/tests/") { continue }

              # Critical files that affect everything - run ALL tests
              if ($file -match "Endpoints/Base/|Extensions/TelemetryExtensions|Common/Contracts/Result|Common/Contracts/Error|Data/Contexts/|Data/Migrations/") {
                Write-Host "[CRITICAL] $file - Running ALL tests" -ForegroundColor Red
                $runAllTests = $true
                break
              }

              # Map file paths to test namespaces
              $matched = $false

              if ($file -match "Endpoints/Beneficiaries/|Services/Beneficiaries/") {
                $testFilters += "Beneficiaries"
                $matched = $true
              }
              elseif ($file -match "Endpoints/Lookups/|Services/Lookup/") {
                $testFilters += "Lookups"
                $matched = $true
              }
              elseif ($file -match "Endpoints/Distributions/|Services/Distribution") {
                $testFilters += "Distributions"
                $matched = $true
              }
              elseif ($file -match "Endpoints/Adjustments/|Services/Adjustment") {
                $testFilters += "Adjustments"
                $matched = $true
              }
              elseif ($file -match "Endpoints/YearEnd/|Services/YearEnd|Services/ProfitShareEdit") {
                $testFilters += "YearEnd"
                $matched = $true
              }
              elseif ($file -match "Endpoints/Military/|Services/Military/") {
                $testFilters += "Military"
                $matched = $true
              }
              elseif ($file -match "Endpoints/Validation/|Services/Validation/") {
                $testFilters += "Validation"
                $matched = $true
              }
              elseif ($file -match "Endpoints/ItOperations/|Services/ItDevOps/") {
                $testFilters += "ItOperations"
                $matched = $true
              }
              elseif ($file -match "Endpoints/Navigations/|Services/Navigations/") {
                $testFilters += "Navigation"
                $matched = $true
              }
              elseif ($file -match "Endpoints/BeneficiaryInquiry/|Services/BeneficiaryInquiry/") {
                $testFilters += "BeneficiaryInquiry"
                $matched = $true
              }
              elseif ($file -match "Endpoints/ProfitDetails/") {
                $testFilters += "ProfitDetails"
                $matched = $true
              }
              elseif ($file -match "OracleHcm/") {
                $testFilters += "OracleHcm"
                $matched = $true
              }
              elseif ($file -match "Services/Reports/|Endpoints/Reports/|Reporting/") {
                $testFilters += "Reports"
                $matched = $true
              }
              elseif ($file -match "Data/Entities/") {
                $testFilters += "Services"
                $matched = $true
              }
              elseif ($file -match "Services/Pay/|Services/Total") {
                $testFilters += "Services"
                $matched = $true
              }
              elseif ($file -match "Security/") {
                $testFilters += "Security"
                $matched = $true
              }
              elseif ($file -match "Common/") {
                $testFilters += "Common"
                $matched = $true
              }
              # Api project root files (Swagger, Program.cs, etc.) - typically infrastructure
              elseif ($file -match "Demoulas\.ProfitSharing\.Api/") {
                # Swagger and startup files are infrastructure - run all endpoint tests
                $testFilters += "Endpoints"
                $matched = $true
              }
              # CachingServices
              elseif ($file -match "CachingServices/") {
                $testFilters += "Services"
                $matched = $true
              }
              # Analyzers - typically don't need runtime tests
              elseif ($file -match "Analyzers/") {
                # Analyzers are compile-time only, skip tests
                $matched = $true
              }

              if (-not $matched) {
                Write-Host "[UNKNOWN] No mapping for: $file - Running ALL tests" -ForegroundColor Yellow
                $runAllTests = $true
                break
              }
            }

            # Get unique filters
            $testFilters = $testFilters | Select-Object -Unique

            Write-Host "`nTest filters:" -ForegroundColor Yellow
            if ($runAllTests) {
              Write-Host "  Running ALL tests (critical or unmapped files changed)" -ForegroundColor Red
            } elseif ($testFilters.Count -eq 0) {
              Write-Host "  No test filters (only test files changed)" -ForegroundColor Green
            } else {
              $testFilters | ForEach-Object { Write-Host "  - $_" -ForegroundColor Cyan }
            }

            # Determine if architecture tests should run
            $runArchitectureTests = $false
            $structuralPatterns = @("Common", "Endpoints", "Services", "Data")
            foreach ($pattern in $structuralPatterns) {
              if ($testFilters -contains $pattern -or $runAllTests) {
                $runArchitectureTests = $true
                break
              }
            }

            # Write decision to artifact
            $decision = @{
              decision = if ($runAllTests) { "RUN_ALL" } else { "SELECTIVE" }
              runAllTests = $runAllTests
              testFilters = @($testFilters)
              runArchitectureTests = $runArchitectureTests
              reason = if ($runAllTests) { "Critical or unmapped files changed" } else { "Selective filters applied" }
            }

            $decision | ConvertTo-Json | Out-File -FilePath "selective-test-decision.json" -Encoding UTF8

            Write-Host "`nTest Execution Decision:" -ForegroundColor Cyan
            Write-Host "  Unit Tests: $(if ($runAllTests) { 'ALL' } elseif ($testFilters.Count -gt 0) { 'SELECTIVE (' + ($testFilters -join ', ') + ')' } else { 'SKIP' })" -ForegroundColor $(if ($runAllTests) { 'Yellow' } elseif ($testFilters.Count -gt 0) { 'Green' } else { 'Yellow' })
            Write-Host "  Architecture Tests: $(if ($runArchitectureTests) { 'RUN' } else { 'SKIP' })" -ForegroundColor $(if ($runArchitectureTests) { 'Green' } else { 'Yellow' })
          }
          catch {
            Write-Host "Error during selective analysis: $_" -ForegroundColor Red
            Write-Host "Falling back to running ALL tests for safety" -ForegroundColor Yellow
            @{
              decision = "RUN_ALL"
              reason = "Analysis error: $_"
            } | ConvertTo-Json | Out-File -FilePath "selective-test-decision.json" -Encoding UTF8
          }

    # ========================================================================
    # FRONTEND TESTS (PR Builds)
    # ========================================================================
    # Purpose: Run frontend unit tests with selective targeting for PRs
    # Runner:  Cloud (node:22-alpine) - frees on-prem resources
    # Used by: PR pipeline, main branch pipeline
    #
    # For PR builds: Runs only tests for changed directories
    # For branch builds: Runs all tests
    #
    # Test patterns: utils, hooks, components, reduxstore, pages/*
    # ========================================================================
    test-frontend: &test-frontend
      name: Build and Test Frontend UI
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      artifacts:
        - src/ui/coverage/**
        - src/ui/FE_Tests/**
      script:
        - cd src/ui
        - echo "Running frontend tests on cloud runner..."

        # Install git for Alpine (needed for diff comparison in PRs)
        - apk add --no-cache git

        # Update npm to latest version
        - npm install -g npm@latest
        - npm config list --json
        - env | grep -i npm_config

        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF

        # Install dependencies
        - npm ci

        # Run tests - only changed areas for PRs, all tests for branch builds
        - |
          if [ -n "$BITBUCKET_PR_DESTINATION_BRANCH" ]; then
              echo "PR build detected - checking for changed files..."
              cd ../..  # Go to repo root for git operations (from src/ui)
              git fetch origin "$BITBUCKET_PR_DESTINATION_BRANCH" --depth=1
              changed_files=$(git diff --name-only --diff-filter=ACMR "origin/$BITBUCKET_PR_DESTINATION_BRANCH"...HEAD | grep '^src/ui/src/' || true)
              cd src/ui

              # ================================================================
              # DYNAMIC DIRECTORY DISCOVERY FOR SELECTIVE TESTING
              # ================================================================
              # Instead of hardcoding directories, we dynamically discover them.
              # This ensures new directories are automatically included in testing.
              #
              # Excluded top-level directories (no testable code):
              #   assets, middleware, Okta, styles, types, test, pages
              #   (pages is handled separately to match subdirectories)
              #
              # Excluded page directories:
              #   Dev (developer utilities)
              # ================================================================

              # Define excluded directories
              excluded_top_level="assets|middleware|Okta|styles|types|test|pages"
              excluded_pages="Dev"

              # Discover top-level directories (e.g., utils, hooks, components, redux, reduxstore)
              top_level_dirs=$(ls -d src/ui/src/*/ 2>/dev/null | xargs -n1 basename | grep -Ev "^($excluded_top_level)$" || true)

              # Discover page directories (e.g., Beneficiaries, Reports, FiscalClose)
              page_dirs=$(ls -d src/ui/src/pages/*/ 2>/dev/null | xargs -n1 basename | grep -Ev "^($excluded_pages)$" || true)

              # Build test patterns based on changed areas
              test_patterns=""

              # Check top-level directories for changes
              for dir in $top_level_dirs; do
                  if echo "$changed_files" | grep -q "^src/ui/src/$dir/"; then
                      test_patterns="$test_patterns src/$dir"
                  fi
              done

              # Check page directories for changes
              for page_dir in $page_dirs; do
                  if echo "$changed_files" | grep -q "^src/ui/src/pages/$page_dir/"; then
                      test_patterns="$test_patterns src/pages/$page_dir"
                  fi
              done

              # Trim leading whitespace
              test_patterns=$(echo "$test_patterns" | sed 's/^ *//')

              if [ -n "$test_patterns" ]; then
                  echo "Running tests for changed areas: $test_patterns"
                  npm run test -- --run $test_patterns
              else
                  echo "No test areas matched changed files - skipping tests"
              fi
          else
              echo "Branch build - running all tests..."
              npm run test
          fi

    generate-buildinfo: &generate-buildinfo
      name: Generate Build Information
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - .buildinfo.json
      script:
        - dotnet tool update --global Demoulas.Common.Build.Cli --no-cache
        - Demoulas.Common.Build.Cli --buildid ${env:BITBUCKET_BUILD_NUMBER} --Branch ${env:BITBUCKET_BRANCH} --CommitHash ${env:BITBUCKET_COMMIT}
        - if (!(Test-Path ".buildinfo.json")) { Write-Error "Failed to generate .buildinfo.json"; exit 1; }

    create-api-artifacts: &create-api-artifacts
      name: Create API Artifacts
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        # Only update the specific tool we need, not all tools globally
        - dotnet tool update --global Demoulas.Common.Build.Cli --no-cache
        - Write-Host ${env:BITBUCKET_BUILD_NUMBER}
        - Write-Host ${env:BITBUCKET_BRANCH}
        - Write-Host ${env:BITBUCKET_COMMIT}
        - Write-Host $(Get-Location)
        - Write-Host $(Get-ChildItem)
        - New-Item -ItemType Directory -Path "dist"

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.Api -c Release -p:PublishProfile=FolderProfile -p:SkipOpenApiSpecGeneration=true -o .\publishOutput

        - Demoulas.Common.Build.Cli --buildid ${env:BITBUCKET_BUILD_NUMBER} --Branch ${env:BITBUCKET_BRANCH} --CommitHash ${env:BITBUCKET_COMMIT}
        - Copy-Item -Path ".buildinfo.json" -Destination ".\publishOutput\"

        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.Api.zip -Force

    create-service-artifacts: &create-service-artifacts
      name: Create Background Service Artifacts
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        - $env:NUGET_ORG = "https://api.nuget.org/v3/index.json"
        - Write-Host $(Get-Location)
        - Write-Host $(Get-ChildItem)
        - New-Item -ItemType Directory -Path "dist"

        # Tool already updated in create-api-artifacts step (runs in parallel)
        # Only update if not already present
        - if (-not (Get-Command Demoulas.Common.Build.Cli -ErrorAction SilentlyContinue)) { dotnet tool update --global Demoulas.Common.Build.Cli --no-cache }

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeeFull.Sync -c Release -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeeFull.Sync.zip -Force

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeeDelta.Sync -c Release -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeeDelta.Sync.zip -Force

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeePayroll.Sync -c Release -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeePayroll.Sync.zip -Force

    create-frontend-artifact-qa: &create-frontend-artifact-qa
      name: Create FrontEnd Artifacts (QA)
      # Run on cloud to free on-premises resources
      image: node:22-alpine
      artifacts:
        - dist/**
      script:
        # Navigate to UI directory
        - cd src/ui

        # Install zip utility and update npm
        - apk add --no-cache zip
        - npm install -g npm@latest

        # Create .npmrc for JFrog access (using bash heredoc syntax)
        - |
          cat > .npmrc << 'EOF'
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF

        # Update package.json version from .buildinfo.json
        - |
          if [ -f ../../.buildinfo.json ]; then
            BUILD_NUMBER=$(grep -o '"buildNumber":"[^"]*"' ../../.buildinfo.json | cut -d'"' -f4)
            BUILD_ID=$(grep -o '"buildId":[0-9]*' ../../.buildinfo.json | cut -d':' -f2)
            if [ -n "$BUILD_NUMBER" ] && [ -n "$BUILD_ID" ]; then
              # Parse BUILD_NUMBER as YYYYmmDD and convert to YYYY.mmDD
              if [ ${#BUILD_NUMBER} -eq 8 ]; then
                YEAR="${BUILD_NUMBER:0:4}"
                MONTH="${BUILD_NUMBER:4:2}"
                DAY="${BUILD_NUMBER:6:2}"
                SEMANTIC_VERSION="${YEAR}.${MONTH}${DAY}.${BUILD_ID}"
              else
                # Fallback if format is unexpected
                SEMANTIC_VERSION="${BUILD_NUMBER}.${BUILD_ID}"
              fi
              node -e "const pkg=require('./package.json'); pkg.version='${SEMANTIC_VERSION}'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');"
              echo "✓ Updated package.json version to $SEMANTIC_VERSION"
              grep '"version"' package.json
            fi
          fi

        # Copy buildinfo.json from artifact to public directory
        - echo "Copying .buildinfo.json from artifact..."
        - cp ../../.buildinfo.json ./public/.buildinfo.json
        - echo "✓ Build info copied to public directory"
        - cat ./public/.buildinfo.json

        # Install dependencies
        - npm ci

        # Build for QA environment
        - npm run build:qa

        # Create dist directory at repo root
        - mkdir -p ../../dist

        # Package artifact using zip
        - cd build
        - zip -r ../../../dist/Demoulas.ProfitSharing.UI.qa.zip .
        - cd ..

        # Verify artifact was created
        - ls -lh ../../dist/Demoulas.ProfitSharing.UI.qa.zip
        - echo "✓ QA artifact created successfully"

    create-frontend-artifact-uat: &create-frontend-artifact-uat
      name: Create FrontEnd Artifacts (UAT)
      # Run on cloud to free on-premises resources
      image: node:22-alpine
      artifacts:
        - dist/**
      script:
        # Navigate to UI directory
        - cd src/ui

        # Install zip utility and update npm
        - apk add --no-cache zip
        - npm install -g npm@latest

        # Create .npmrc for JFrog access (using bash heredoc syntax)
        - |
          cat > .npmrc << 'EOF'
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF

        # Update package.json version from .buildinfo.json
        - |
          if [ -f ../../.buildinfo.json ]; then
            BUILD_NUMBER=$(grep -o '"buildNumber":"[^"]*"' ../../.buildinfo.json | cut -d'"' -f4)
            BUILD_ID=$(grep -o '"buildId":[0-9]*' ../../.buildinfo.json | cut -d':' -f2)
            if [ -n "$BUILD_NUMBER" ] && [ -n "$BUILD_ID" ]; then
              # Parse BUILD_NUMBER as YYYYmmDD and convert to YYYY.mmDD
              if [ ${#BUILD_NUMBER} -eq 8 ]; then
                YEAR="${BUILD_NUMBER:0:4}"
                MONTH="${BUILD_NUMBER:4:2}"
                DAY="${BUILD_NUMBER:6:2}"
                SEMANTIC_VERSION="${YEAR}.${MONTH}${DAY}.${BUILD_ID}"
              else
                # Fallback if format is unexpected
                SEMANTIC_VERSION="${BUILD_NUMBER}.${BUILD_ID}"
              fi
              node -e "const pkg=require('./package.json'); pkg.version='${SEMANTIC_VERSION}'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');"
              echo "✓ Updated package.json version to $SEMANTIC_VERSION"
              grep '"version"' package.json
            fi
          fi

        # Copy buildinfo.json from artifact to public directory
        - echo "Copying .buildinfo.json from artifact..."
        - cp ../../.buildinfo.json ./public/.buildinfo.json
        - echo "✓ Build info copied to public directory"
        - cat ./public/.buildinfo.json

        # Install dependencies
        - npm ci

        # Build for UAT environment
        - npm run build:uat

        # Create dist directory at repo root
        - mkdir -p ../../dist

        # Package artifact using zip
        - cd build
        - zip -r ../../../dist/Demoulas.ProfitSharing.UI.uat.zip .
        - cd ..

        # Verify artifact was created
        - ls -lh ../../dist/Demoulas.ProfitSharing.UI.uat.zip
        - echo "✓ UAT artifact created successfully"

    upgrade-database: &upgrade-database
      name: Upgrade Database
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        - |
          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\output
          if ($LASTEXITCODE -ne 0) { Write-Error "Database project build failed. Exiting."; exit 1 }

          $environment = $env:Environment
          $action = $env:Action
          $sourceSchema = $env:SourceSchema
          $currentYear = $env:CurrentYear

          if (-not $environment) { $environment = "QA" }
          if (-not $action) { $action = "upgrade-db" }
          if (-not $sourceSchema) { $sourceSchema = "PROFITSHARE" }
          if (-not $currentYear) { $currentYear = "2024" }

          if ($environment -eq "QA") {
            $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_QA            
          }

          if ($environment -eq "UAT") {
            $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT            
          }

          if (-not $sourceSchema) {
            Write-Error "Source schema is undefined. Exiting."; exit 1
          }

          Write-Host "Running database upgrade with action: $action"
          Write-Host "Target environment: $environment"
          Write-Host "Source schema: $sourceSchema"
          Write-Host "Current directory: $(Get-Location)"

          # -------------------------------------------------------------
          # Full Reset & Import (Nuclear-Option parity)
          #   Action: full-reset-and-import
          #   Steps: drop-recreate-db -> import-from-ready -> import-from-navigation
          # -------------------------------------------------------------
          if ($action -eq "full-reset-and-import") {
            if ($environment -ne "QA") {
              Write-Error "Action 'full-reset-and-import' is restricted to QA environment only. Current environment: $environment"; exit 1
            }
            Write-Host "[Full Reset] Dropping & recreating schema $sourceSchema"
            .\output\Demoulas.ProfitSharing.Data.Cli drop-recreate-db --connection-name ProfitSharing --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Drop/Recreate failed. Exiting"; exit 1 }

            Write-Host "[Full Reset] Importing from READY into $sourceSchema"
            .\output\Demoulas.ProfitSharing.Data.Cli import-from-ready --connection-name ProfitSharing --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Import from READY failed. Exiting"; exit 1 }

            $navigationFile = ".\src\database\ready_import\Navigations\add-navigation-data.sql"
            if ($environment -eq "UAT") {
              $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
              Write-Host "[Full Reset] Using UAT navigation data"
            }

            Write-Host "[Full Reset] Importing navigation data from $navigationFile"
            .\output\Demoulas.ProfitSharing.Data.Cli import-from-navigation --connection-name ProfitSharing --sql-file $navigationFile --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Navigation import failed. Exiting"; exit 1 }

            Write-Host "[Full Reset] Completed successfully."
            exit 0
          }

          .\output\Demoulas.ProfitSharing.Data.Cli $action --connection-name ProfitSharing --output-file ".\dist\migration.sql" --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $sourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Database upgrade failed. Exiting"; exit 1 }

          # Determine which navigation file to use based on action or environment
          $navigationFile = ".\src\database\ready_import\Navigations\add-navigation-data.sql"
          if ($action -eq "import-uat-navigation" -or $environment -eq "UAT") {
            $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
            Write-Host "Using UAT navigation data"
          }

          .\output\Demoulas.ProfitSharing.Data.Cli import-from-navigation  --connection-name ProfitSharing --output-file ".\dist\navigations.sql" --sql-file $navigationFile --source-schema $sourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Database upgrade failed. Exiting"; exit 1 }

          if ($action -eq "validate-import") {
            .\output\Demoulas.ProfitSharing.Data.Cli validate-import --connection-name ProfitSharing --sql-file ".\src\database\ready_import\Import Validations.sql" --source-schema $sourceSchema --current-year $currentYear
            if ($LASTEXITCODE -ne 0) { Write-Error "Database import validation failed. Exiting"; exit 1 }
          }

    uat-drop-recreate-db: &uat-drop-recreate-db
      name: UAT Drop & Recreate DB
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:Action = "drop-recreate-db"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          Write-Host "Dropping & recreating UAT database (schema: $env:SourceSchema)"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli $env:Action --connection-name ProfitSharing --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Drop/Recreate failed."; exit 1 }
          Write-Host "Drop & recreate completed."

    uat-import-from-ready: &uat-import-from-ready
      name: UAT Import From READY
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:Action = "import-from-ready"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          Write-Host "Importing data from READY into UAT schema: $env:SourceSchema"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli $env:Action --connection-name ProfitSharing --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Import from READY failed."; exit 1 }
          Write-Host "Import from READY completed."

    uat-import-uat-navigation: &uat-import-uat-navigation
      name: UAT Import Navigation Data
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
          Write-Host "Importing UAT navigation data using $navigationFile"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli import-from-navigation --connection-name ProfitSharing --sql-file $navigationFile --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Navigation import failed."; exit 1 }
          Write-Host "Navigation import completed."

    uat-validate-import: &uat-validate-import
      name: UAT Validate Import
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          $currentYear = (Get-Date).Year

          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\output
          if ($LASTEXITCODE -ne 0) { Write-Error "Database project build failed. Exiting."; exit 1 }

          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }

          Write-Host "Validating UAT import for schema $env:SourceSchema and year $currentYear"
          .\output\Demoulas.ProfitSharing.Data.Cli validate-import --connection-name ProfitSharing --sql-file ".\src\database\ready_import\Import Validations.sql" --source-schema $env:SourceSchema --current-year $currentYear
          if ($LASTEXITCODE -ne 0) { Write-Error "Import validation failed."; exit 1 }
          Write-Host "Import validation completed."

    # ========================================================================
    # DATABASE CLI BUILD
    # ========================================================================
    # Purpose: Build the database CLI tool for migrations and data operations
    # Runner:  Windows self-hosted
    # ========================================================================
    db-cli-build-artifact: &db-cli-build-artifact
      name: Build DB CLI (artifact)
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dbcli/**
      script:
        - |
          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\dbcli
          if ($LASTEXITCODE -ne 0) { Write-Error "Database CLI build failed. Exiting."; exit 1 }
          Write-Host "DB CLI built to .\\dbcli"

    # ========================================================================
    # SECURITY AUDITS
    # ========================================================================
    # These steps check for known vulnerabilities in dependencies.
    # Run early in the pipeline to fail fast on security issues.
    # ========================================================================

    # Backend: NuGet vulnerability scan
    audit-backend: &audit-backend
      name: "Check Backend API for vulnerabilities"
      runs-on:
        - windows
        - self.hosted
      script:
        - $env:SolutionDir = ".\src\services"
        - echo "Checking dotnet vulnerabilities"
        - cd $env:SolutionDir

        - dotnet --info
        - dotnet nuget list source
        - dotnet restore Demoulas.ProfitSharing.slnx

        - |
          $output = dotnet list Demoulas.ProfitSharing.slnx package --vulnerable --include-transitive --source https://api.nuget.org/v3/index.json
          if ($output -match "has the following vulnerable packages") {
            Write-Host "Vulnerabilities found!"
            Write-Host $output
            exit 1
          } else {
            Write-Host "No vulnerabilities found."
            exit 0
          }

    # Frontend: NPM vulnerability scan
    audit-frontend: &audit-frontend
      name: "Check frontend for vulnerabilities"
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      script:
        - cd src/ui
        - echo "Checking npm vulnerabilities on cloud runner..."
        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        - npm audit --audit-level=high --production

    # ========================================================================
    # CODE QUALITY CHECKS
    # ========================================================================
    # Linting and type checking. Run early for fast feedback on code issues.
    # ========================================================================

    # Frontend: ESLint + TypeScript (selective for PRs)
    frontend-lint: &frontend-lint
      name: Frontend TSC + Lint
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      script:
        - cd src/ui
        - echo "Running frontend tsc and linting on cloud runner..."

        # Install git for Alpine (needed for diff comparison in PRs)
        - apk add --no-cache git

        # Update npm to latest version
        - npm install -g npm@latest

        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF

        # Install dependencies
        - npm ci

        # Run lint - only changed files for PRs, all files for branch builds
        - |
          if [ -n "$BITBUCKET_PR_DESTINATION_BRANCH" ]; then
              echo "PR build detected - checking for changed files..."
              cd ../..  # Go to repo root for git operations (from src/ui)
              git fetch origin "$BITBUCKET_PR_DESTINATION_BRANCH" --depth=1
              changed_files=$(git diff --name-only --diff-filter=ACMR "origin/$BITBUCKET_PR_DESTINATION_BRANCH"...HEAD | grep '^src/ui/src/' | grep -E '\.(ts|tsx|js|jsx)$' | sed 's|^src/ui/||' || true)
              cd src/ui

              if [ -n "$changed_files" ]; then
                  file_count=$(echo "$changed_files" | wc -l | tr -d ' ')
                  echo "Linting $file_count changed file(s)..."
                  echo "$changed_files" | xargs npx eslint
              else
                  echo "No lintable files changed in src/ui/src/"
              fi
          else
              echo "Branch build - linting all files..."
              npm run lint
          fi

        - npx tsc -b --noEmit

    # Backend API: Zalando API Guidelines linting
    api-lint: &api-lint
      name: "API Linting (Zalando Guidelines)"
      # Runs on self-hosted Windows runner
      runs-on:
        - self.hosted
        - windows
      max-time: 10
      script:
        - |
          # API linting using centralized PowerShell script
          # Script location: scripts/Lint-Api.ps1
          # For local development: .\scripts\Lint-Api.ps1 or npm run lint:api (from src/ui/)

          $output = New-Item -ItemType Directory -Path "reports/api-lint" -Force
          & ./scripts/Lint-Api.ps1 -QaBaseUrl "${env:QA_BASE_URL}:8443" -OutputFormat junit -OutputFile "./reports/api-lint/junit.xml"
          exit $LASTEXITCODE
      artifacts:
        - reports/api-lint/**

    # ========================================================================
    # SECRET SCANNING
    # ========================================================================
    # Detect accidentally committed secrets (API keys, passwords, etc.)
    # Uses Gitleaks for comprehensive secret detection.
    # ========================================================================
    secret-scan: &secret-scan
      name: "Secret scan (Gitleaks)"
      # Runs on Bitbucket Cloud by default (Docker image)
      image: zricethezav/gitleaks:latest
      max-time: 5
      artifacts:
        - reports/**
      script:
        - mkdir -p reports
        - gitleaks detect --source . --config gitleaks.toml --redact --no-banner --report-format json --report-path reports/gitleaks.json --exit-code 0
        - echo "Gitleaks findings (redacted JSON):"
        - head -c 200000 reports/gitleaks.json || true
        - |
          # Robust leak evaluation without python dependency
          if [ ! -s reports/gitleaks.json ]; then
            echo "No leaks found (empty report).";
          else
            if command -v jq >/dev/null 2>&1; then
              findings_count=$(jq 'if type=="array" then length elif (.findings|type? == "array") then (.findings|length) else 0 end' reports/gitleaks.json 2>/dev/null || echo 0)
            else
              # Fallback: treat literal [] or [ ] as zero, anything else non-empty as 1
              if grep -q '"Description"' reports/gitleaks.json; then
                # Some formats include fields; attempt crude count of occurrences of "RuleID"
                findings_count=$(grep -o '"RuleID"' reports/gitleaks.json | wc -l | tr -d ' ')
              elif grep -Eq '^\s*\[\s*\]\s*$' reports/gitleaks.json; then
                findings_count=0
              else
                # Non-empty & not literal empty array: assume at least 1
                findings_count=1
              fi
            fi
            echo "Gitleaks findings count: $findings_count"
            if [ "${findings_count}" -gt 0 ]; then
              echo "Leaks found. Failing the build.";
              exit 1;
            else
              echo "No leaks found.";
            fi
          fi
    run-playwright-tests: &run-playwright-tests
      name: "Run Playwright E2E Tests (QA)"
      runs-on:
        - windows
        - self.hosted
        - volta
      artifacts:
        - ui/playwright-report/**
        - ui/test-results/**
        - src/UI/playwright-report/**
        - src/UI/test-results/**
        - playwright-artifacts/**
      script:
        - |
          <#
            Playwright E2E Runner (QA)
            Sections:
              1) Locate project dir
              2) Ensure Node version (Volta)
              3) Materialize .env from QA_Playwright variable
              4) Install deps & browsers
              5) Execute tests (JUnit + HTML)
              6) Collect artifacts & set exit code
          #>

          Write-Host "[1] Locate Playwright project directory" -ForegroundColor Cyan
          $candidateDirs = @('ui','src/UI','src/ui')
          $playwrightDir = $candidateDirs | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $playwrightDir) { Write-Error "Playwright project directory not found. Checked: $($candidateDirs -join ', ')"; exit 1 }
          Set-Location $playwrightDir
          Write-Host "Using directory: $playwrightDir"

          Write-Host "[2] Ensure compatible Node.js version" -ForegroundColor Cyan
          $targetNode = '22.16.0'
          try { $currentNode = (node -v) 2>$null } catch { $currentNode = 'unknown' }
          Write-Host "Current node: $currentNode"
          if (Get-Command volta -ErrorAction SilentlyContinue) {
            volta install node@$targetNode | Out-Null
            Write-Host "Node after install: $(node -v)"
          } else {
            Write-Host "Volta unavailable; proceeding with existing Node version" -ForegroundColor Yellow
          }

          Write-Host "[3] Build .env from QA_Playwright variable" -ForegroundColor Cyan
          if (-not $env:QA_Playwright) { Write-Error "QA_Playwright variable not set"; exit 1 }
          $raw = $env:QA_Playwright
          # Tokenize by whitespace; handle patterns like KEY=value and KEY= value
          $parts = $raw -split '\s+' | Where-Object { $_ -and ($_ -notmatch '^\s*$') }
          $kv = @{}
          for ($i = 0; $i -lt $parts.Length; $i++) {
            $p = $parts[$i]
            if ($p -match '^([A-Za-z_][A-Za-z0-9_]*)=(.*)$') {
              $k = $matches[1]
              $v = $matches[2]
              if ($v -eq '') {
                # Value may be next token (e.g. USER_NAME= rharding)
                if ($i + 1 -lt $parts.Length -and ($parts[$i+1] -notmatch '^[A-Za-z_][A-Za-z0-9_]*=')) {
                  $v = $parts[$i+1]
                  $i++
                }
              }
              $v = $v.Trim().Trim('"').Trim("'")
              if (-not $kv.ContainsKey($k)) { $kv[$k] = $v }
            }
          }
          $userKey = ($kv.Keys | Where-Object { $_ -in 'USER_NAME','USERNAME','USER','LOGIN' } | Select-Object -First 1)
          $passKey = ($kv.Keys | Where-Object { $_ -in 'PASSWORD','PASS','PWD' } | Select-Object -First 1)
          $userVal = if ($userKey) { $kv[$userKey] } else { '' }
          $passVal = if ($passKey) { $kv[$passKey] } else { '' }
          $ciVal = if ($kv.ContainsKey('CI')) { $kv['CI'] } else { '' }
          $qaVal = if ($kv.ContainsKey('QA')) { $kv['QA'] } else { '' }
          if (-not $userVal -or -not $passVal) {
            Write-Host 'Parsed keys (no secrets): ' + ($kv.Keys -join ', ')
            Write-Error 'Missing USER credential (USER_NAME/USERNAME/USER/LOGIN) and/or PASSWORD (PASSWORD/PASS/PWD) in QA_Playwright value.'; exit 1
          }
          $lines = @(
            "CI=$ciVal",
            "QA=$qaVal",
            "USER_NAME=$userVal",
            "PASSWORD=$passVal"
          )
          Set-Content ./.env -Value $lines
          Write-Host ".env keys emitted: CI, QA, USER_NAME, PASSWORD"
          # Some configs expect a .playwright.env specifically; create it if not present
          Copy-Item ./.env ./.playwright.env -Force

          Write-Host "[4] Install dependencies & browsers" -ForegroundColor Cyan
          if (Test-Path node_modules) { Remove-Item -Recurse -Force node_modules }
          npm ci
          npx playwright install --with-deps; if ($LASTEXITCODE -ne 0) { npx playwright install }

          Write-Host "[5] Run tests" -ForegroundColor Cyan
          New-Item -ItemType Directory -Path test-results -Force | Out-Null

          # Diagnostic: show any duplicate playwright test packages
          Get-ChildItem -Path node_modules -Filter playwright -Recurse -Depth 3 -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object { Write-Host "Found playwright path: $($_.FullName)" }
          Get-ChildItem -Path node_modules -Filter "@playwright" -Recurse -Depth 5 -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object { Write-Host "Found @playwright path: $($_.FullName)" }
          # Use direct CLI to avoid potential global 'playwright' package ambiguity
          $playwrightCli = Join-Path (Resolve-Path ./node_modules/@playwright/test).Path "cli.js"
          if (-not (Test-Path $playwrightCli)) { Write-Error "Playwright CLI not found at $playwrightCli"; Get-ChildItem node_modules/@playwright/test -Recurse -Depth 2; exit 1 }
          node $playwrightCli test --reporter "list,junit" --config=playwright.config.ts --output=test-results --workers=1
          $pwExit = $LASTEXITCODE

          Write-Host "[6] Prepare Bitbucket test-reports ingestion" -ForegroundColor Cyan
          $repoRoot = $env:BITBUCKET_CLONE_DIR; if (-not $repoRoot) { $repoRoot = (Resolve-Path '..').Path }
          $bbTestRoot = Join-Path $repoRoot 'test-reports'
          $bbPlaywrightDir = Join-Path $bbTestRoot 'playwright'
          if (!(Test-Path $bbPlaywrightDir)) { New-Item -ItemType Directory -Path $bbPlaywrightDir -Force | Out-Null }
          # Locate a junit xml (reporter names can vary). Prefer explicit junit.xml if present.
          $junitCandidate = @(
            Get-ChildItem -Path test-results -Recurse -Filter junit*.xml -ErrorAction SilentlyContinue
            Get-ChildItem -Path test-results -Recurse -Filter *.xml -ErrorAction SilentlyContinue | Where-Object { (Get-Content $_.FullName -TotalCount 5) -match '<testsuite' }
          ) | Where-Object { $_ } | Select-Object -First 1
          if ($junitCandidate) {
            Copy-Item $junitCandidate.FullName (Join-Path $bbPlaywrightDir 'junit.xml') -Force
            Write-Host "Copied JUnit report to test-reports/playwright/junit.xml"
          } else {
            Write-Host "No JUnit XML found to copy." -ForegroundColor Yellow
          }

          Write-Host "[7] Collect artifacts" -ForegroundColor Cyan
          $artifactRoot = Join-Path $repoRoot 'playwright-artifacts'
            if (!(Test-Path $artifactRoot)) { New-Item -ItemType Directory -Path $artifactRoot | Out-Null }
          foreach ($d in 'playwright-report','test-results') { if (Test-Path $d) { Copy-Item -Recurse -Force $d (Join-Path $artifactRoot $d) } }

          Write-Host "[8] Finalize with exit code $pwExit" -ForegroundColor Cyan
          exit $pwExit

    create-release-tag: &create-release-tag
      name: Create Release Tag
      script:
        - |
          echo "Reading build information..."
          if [ ! -f ".buildinfo.json" ]; then
            echo "Error: .buildinfo.json not found"
            exit 1
          fi

          # Parse buildNumber and buildId from JSON
          BUILD_NUMBER=$(grep -o '"buildNumber":"[^"]*"' .buildinfo.json | cut -d'"' -f4)
          BUILD_ID=$(grep -o '"buildId":[0-9]*' .buildinfo.json | cut -d':' -f2)

          if [ -z "$BUILD_NUMBER" ] || [ -z "$BUILD_ID" ]; then
            echo "Error: Could not parse buildNumber or buildId from .buildinfo.json"
            cat .buildinfo.json
            exit 1
          fi

          TAG_NAME="${BUILD_NUMBER}.${BUILD_ID}"
          TAG_MESSAGE="Release build ${BUILD_NUMBER}.${BUILD_ID} deployed to QA"

          echo "Creating release tag: $TAG_NAME"
          echo "Message: $TAG_MESSAGE"

          git config user.email "bitbucket-pipeline@demoulas.com"
          git config user.name "Bitbucket Pipeline"

          # Check if tag already exists
          if git tag -l | grep -q "^${TAG_NAME}$"; then
            echo "Warning: Tag '$TAG_NAME' already exists locally. Skipping tag creation."
            exit 0
          fi

          if git ls-remote --tags origin | grep -q "refs/tags/${TAG_NAME}$"; then
            echo "Warning: Tag '$TAG_NAME' already exists on remote. Skipping tag creation."
            exit 0
          fi

          # Create and push tag
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"
          git push origin "refs/tags/$TAG_NAME"

          echo "✓ Release tag '$TAG_NAME' created and pushed successfully"

# ============================================================================
#                                  PIPELINES
# ============================================================================
# Pipeline definitions for different triggers (branches, PRs, manual).
# ============================================================================

pipelines:
  # ==========================================================================
  # BRANCH PIPELINES
  # ==========================================================================
  # Triggered automatically when code is pushed to specific branches.
  # ==========================================================================
  branches:
    # ------------------------------------------------------------------------
    # RELEASE BRANCH PIPELINE (main)
    # ------------------------------------------------------------------------
    # Full CI/CD: Build → Test → Deploy to QA → Deploy to UAT
    # All steps run regardless of what changed (no selective testing)
    # ------------------------------------------------------------------------
    release:
      # Stage 1: Build and test
      # Stage 1: Code quality checks (fail fast)
      - step: *frontend-lint
      # Stage 2: Run audits and security scans only if build succeeds
      - parallel:
          - step: *audit-frontend
          - step: *audit-backend
      # Stage 3: Build and test
      - parallel:
          - step: *build-and-test-backend
          - step: *test-frontend
      # Stage 2: Generate build information (Windows, ~30 seconds)
      - step: *generate-buildinfo
      # Stage 3: Create artifacts (API/services on Windows, UI builds in parallel on cloud)
      - parallel:
          - step: *create-api-artifacts
          - step: *create-service-artifacts
          - step: *create-frontend-artifact-qa
          - step: *db-cli-build-artifact
      # Stage 4: QA Deployment
      - step:
          name: "Application Deployment (QA)"
          runs-on:
            - windows
            - self.hosted
          deployment: QA
          trigger: "manual"
          script:
            - $env:ENV = "QA"
            - $env:API_SERVER_QA = "appt23d"
            - |
              try {
                pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/EmployeeDelta'
                pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/EmployeeFull'
                pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/Payroll'
                pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/inetpub/wwwroot/api'
                Write-Host "Deploying web application..." -ForegroundColor Cyan
                $env:API_ARTIFACT_NAME = "Demoulas.ProfitSharing.Api.zip"
                $env:UI_ARTIFACT_NAME = "Demoulas.ProfitSharing.UI.QA.zip"
                pwsh .\scripts\webDeploy.ps1 $env:ENV $env:API_SERVER_QA $env:API_ARTIFACT_NAME $env:UI_ARTIFACT_NAME
                Write-Host "Deploying background service..." -ForegroundColor Cyan
                pwsh .\scripts\servicesDeploy.ps1 ${env:ENV} $env:API_SERVER_QA
                Write-Host "QA deployment completed successfully" -ForegroundColor Green
                pwsh .\scripts\Notify-Teams.ps1 -Status SUCCESS -Environment QA -Step Deployment
              }
              catch {
                $env:DEPLOY_ERROR = $_.Exception.Message
                Write-Host "QA deployment failed" -ForegroundColor Red
                pwsh .\scripts\Notify-Teams.ps1 -Status FAILURE -Environment QA -Step Deployment -ErrorMessage $env:DEPLOY_ERROR
                exit 1
              }
      - step: *upgrade-database
      - step:
          name: "Checking API Health"
          runs-on:
            - windows
            - self.hosted
          script:
            - |
              $env:API_SERVER_QA = "appt23d"
              try {
                pwsh -File ./scripts/Check-Health.ps1 -Url $env:QA_BASE_URL -envServerName $env:API_SERVER_QA
                Write-Host "API health check passed" -ForegroundColor Green
              }
              catch {
                Write-Host "API health check failed" -ForegroundColor Red
                pwsh .\scripts\Notify-Teams.ps1 -Status FAILURE -Environment QA -Step HealthCheck -ErrorMessage $_.Exception.Message
                exit 1
              }

      # Stage 5: Create Release Tag
      - step: *create-release-tag

      # Stage 6: UAT Promotion Gate
      - step:
          name: "Gate: Promote to UAT"
          runs-on:
            - windows
            - self.hosted
          trigger: "manual"
          script:
            - echo "Manual approval granted. Continuing to UAT deployment & data operations."
            - |
              Write-Host "Release context:"
              Write-Host ("  Build: " + $env:BITBUCKET_BUILD_NUMBER)
              Write-Host ("  Branch: " + $env:BITBUCKET_BRANCH)
              Write-Host ("  Commit: " + $env:BITBUCKET_COMMIT)
              Write-Host ("  QA API: " + $env:QA_BASE_URL)
              Write-Host "Artifacts in ./dist:"
              if (Test-Path .\dist) {
                Get-ChildItem -Recurse -File .\dist | ForEach-Object {
                  "{0,10} bytes  {1}" -f $_.Length, $_.FullName
                }
              } else {
                Write-Host "  (no dist folder found)"
              }
              Write-Host "Planned UAT sequence:"
              Write-Host "  1) Drop & Recreate DB (parallel with app deploy)"
              Write-Host "  2) App deploy + Import from READY (reusing artifacts from Stage 3)"
              Write-Host "  3) Import UAT navigation"
              Write-Host "  4) Parallel: Validate import + UAT API health check"

      - step: *create-frontend-artifact-uat
      # Stage 7a: UAT Drop & Recreate DB (prerequisite)
      - step: *uat-drop-recreate-db
      # Stage 7b: UAT Deployment & Import in Parallel
      - parallel:
          - step:
              name: "Application Deployment UAT"
              runs-on:
                - windows
                - self.hosted
              deployment: UAT
              script:
                - |
                  try {
                    Write-Host "Deploying application to UAT (reusing API artifact from Stage 2)..." -ForegroundColor Cyan
                    $env:API_SERVER_UAT = "appt24d"
                    $env:ENV = "UAT"
                    pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/EmployeeDelta'
                    pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/EmployeeFull'
                    pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/Payroll'
                    pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/inetpub/wwwroot/api'
                    Write-Host "Deploying web application..." -ForegroundColor Cyan
                    $env:API_ARTIFACT_NAME = "Demoulas.ProfitSharing.Api.zip"
                    $env:UI_ARTIFACT_NAME = "Demoulas.ProfitSharing.UI.UAT.zip"
                    pwsh .\scripts\webDeploy.ps1 $env:ENV $env:API_SERVER_UAT $env:API_ARTIFACT_NAME $env:UI_ARTIFACT_NAME
                    Write-Host "Deploying background service..." -ForegroundColor Cyan
                    pwsh .\scripts\servicesDeploy.ps1 ${env:ENV} $env:API_SERVER_UAT
                    Write-Host "UAT deployment completed successfully" -ForegroundColor Green
                    pwsh .\scripts\Notify-Teams.ps1 -Status SUCCESS -Environment UAT -Step Deployment
                  }
                  catch {
                    $env:DEPLOY_ERROR = $_.Exception.Message
                    Write-Host "UAT deployment failed" -ForegroundColor Red
                    pwsh .\scripts\Notify-Teams.ps1 -Status FAILURE -Environment UAT -Step Deployment -ErrorMessage $env:DEPLOY_ERROR
                    exit 1
                  }
          - step: *uat-import-from-ready
      # Stage 7c: UAT Post-Deployment Steps
      - step: *uat-import-uat-navigation
      - step: *uat-validate-import

    # ------------------------------------------------------------------------
    # DEVELOP BRANCH PIPELINE
    # ------------------------------------------------------------------------
    # Optimized CI: Only builds/tests what changed since last successful build
    #
    # Uses rolling tag 'last-successful-develop-build' to track baseline.
    # Steps check develop-test-decision.json and skip if their area unchanged.
    #
    # Flow:
    # 1. Analyze changes since last success → outputs decision JSON
    # 2. Frontend lint (if frontend changed)
    # 3. Audits (frontend/backend, if respective area changed)
    # 4. Tests (frontend/backend, if respective area changed)
    # 5. Update success tag (only if all steps pass)
    # ------------------------------------------------------------------------
    develop:
      # Stage 0: Analyze what changed since last successful build
      - step: *selective-develop-analysis

      # Stage 1: Code quality checks (fail fast) - only if frontend changed
      - step:
          name: Front TSC + Lint (Develop)
          image: node:22-alpine
          max-time: 10
          script:
            - |
              echo "Checking develop-test-decision.json..."
              if [ -f "develop-test-decision.json" ]; then
                runFrontend=$(grep -o '"runFrontend":[^,}]*' develop-test-decision.json | cut -d':' -f2 | tr -d ' \n\r')
                if [ "$runFrontend" = "false" ]; then
                  echo "SKIP: No frontend changes detected"
                  exit 0
                fi
              fi
              echo "Running frontend lint..."

              cd src/ui
              apk add --no-cache git
              npm install -g npm@latest
              cat > .npmrc << EOF
              registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
              //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
              EOF
              npm ci
              npm run lint
              npx tsc -b --noEmit

      # Stage 2: Run audits - conditional based on changes
      - parallel:
          - step:
              name: Front check vulnerabilities (Develop)
              image: node:22-alpine
              max-time: 10
              script:
                - |
                  echo "Checking develop-test-decision.json..."
                  if [ -f "develop-test-decision.json" ]; then
                    runFrontend=$(grep -o '"runFrontend":[^,}]*' develop-test-decision.json | cut -d':' -f2 | tr -d ' \n\r')
                    if [ "$runFrontend" = "false" ]; then
                      echo "SKIP: No frontend changes detected"
                      exit 0
                    fi
                  fi
                  echo "Running frontend audit..."

                  cd src/ui
                  cat > .npmrc << EOF
                  registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
                  //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
                  EOF
                  npm audit --audit-level=high --production

          - step:
              name: Back check vulnerabilities (Develop)
              runs-on:
                - windows
                - self.hosted
              script:
                - |
                  # Check if backend audit should run
                  Write-Host "Checking develop-test-decision.json..." -ForegroundColor Cyan
                  if (Test-Path "develop-test-decision.json") {
                    $decision = Get-Content "develop-test-decision.json" -Raw | ConvertFrom-Json
                    if ($decision.runBackend -eq $false) {
                      Write-Host "SKIP: No backend changes detected" -ForegroundColor Yellow
                      exit 0
                    }
                  }
                  Write-Host "Running backend audit..." -ForegroundColor Cyan

                  # Run vulnerability check
                  $env:SolutionDir = ".\src\services"
                  Write-Host "Checking dotnet vulnerabilities"
                  cd $env:SolutionDir
                  dotnet --info
                  dotnet nuget list source
                  dotnet restore Demoulas.ProfitSharing.slnx

                  $output = dotnet list Demoulas.ProfitSharing.slnx package --vulnerable --include-transitive --source https://api.nuget.org/v3/index.json
                  if ($output -match "has the following vulnerable packages") {
                    Write-Host "Vulnerabilities found!"
                    Write-Host $output
                    exit 1
                  } else {
                    Write-Host "No vulnerabilities found."
                    exit 0
                  }

      # Stage 3: Build and test - conditional based on changes
      - parallel:
          - step:
              name: Back Unit + Arch Test (Develop)
              runs-on:
                - windows
                - self.hosted
              artifacts:
                - test-reports/**
              script:
                - |
                  # Check if backend tests should run
                  Write-Host "Checking develop-test-decision.json..." -ForegroundColor Cyan
                  if (Test-Path "develop-test-decision.json") {
                    $decision = Get-Content "develop-test-decision.json" -Raw | ConvertFrom-Json
                    if ($decision.runBackend -eq $false) {
                      Write-Host "SKIP: No backend changes detected" -ForegroundColor Yellow
                      exit 0
                    }
                  }
                  Write-Host "Running backend tests..." -ForegroundColor Cyan

                  # Set environment variables
                  $env:NUGET_ORG = "https://api.nuget.org/v3/index.json"

                  # Verify .NET SDK
                  $dotnetSdkList = dotnet --list-sdks
                  Write-Output "Installed .NET SDKs:"
                  Write-Output $dotnetSdkList
                  $dotnetSdkRequired = $dotnetSdkList | Select-String "^10\."
                  if (-not $dotnetSdkRequired) {
                    Write-Error "FAILED: .NET 10 SDK is required but not available."
                    exit 1
                  }

                  # Build once for all tests
                  Write-Host "`n========================================" -ForegroundColor Cyan
                  Write-Host "Building solution..." -ForegroundColor Cyan
                  Write-Host "========================================" -ForegroundColor Cyan
                  dotnet clean src/services/Demoulas.ProfitSharing.slnx --configuration Release
                  dotnet restore src/services/Demoulas.ProfitSharing.slnx
                  dotnet build src/services/Demoulas.ProfitSharing.slnx --configuration Release --no-incremental --no-restore

                  # Run Unit Tests
                  Write-Host "`n========================================" -ForegroundColor Cyan
                  Write-Host "Running Unit Tests..." -ForegroundColor Cyan
                  Write-Host "========================================" -ForegroundColor Cyan
                  $unitTestsPath = "../../../../test-reports/build_${env:BITBUCKET_BUILD_NUMBER}/unit-tests"
                  mkdir -Force -Path $unitTestsPath
                  $unitTestExe = "src/services/tests/Demoulas.ProfitSharing.UnitTests/bin/Release/net10.0/Demoulas.ProfitSharing.UnitTests.exe"
                  & $unitTestExe -jUnit "$unitTestsPath/junit.xml"
                  $unitTestExit = $LASTEXITCODE

                  # Run Architecture Tests
                  Write-Host "`n========================================" -ForegroundColor Cyan
                  Write-Host "Running Architecture Tests..." -ForegroundColor Cyan
                  Write-Host "========================================" -ForegroundColor Cyan
                  $archTestsPath = "../../../../test-reports/build_${env:BITBUCKET_BUILD_NUMBER}/architecture-tests"
                  mkdir -Force -Path $archTestsPath
                  $archTestExe = "src/services/tests/Demoulas.ProfitSharing.UnitTests.Architecture/bin/Release/net10.0/Demoulas.ProfitSharing.UnitTests.Architecture.exe"
                  & $archTestExe -jUnit "$archTestsPath/junit.xml"
                  $archTestExit = $LASTEXITCODE

                  # Report results
                  Write-Host "`n========================================" -ForegroundColor Cyan
                  Write-Host "Test Results Summary" -ForegroundColor Cyan
                  Write-Host "========================================" -ForegroundColor Cyan
                  Write-Host "Unit Tests: $(if ($unitTestExit -eq 0) { 'PASSED' } else { 'FAILED' })" -ForegroundColor $(if ($unitTestExit -eq 0) { 'Green' } else { 'Red' })
                  Write-Host "Architecture Tests: $(if ($archTestExit -eq 0) { 'PASSED' } else { 'FAILED' })" -ForegroundColor $(if ($archTestExit -eq 0) { 'Green' } else { 'Red' })

                  # Exit with failure if either test suite failed
                  if ($unitTestExit -ne 0 -or $archTestExit -ne 0) {
                    Write-Error "One or more test suites failed"
                    exit 1
                  }

          - step:
              name: Frontend Unit Tests (Develop)
              image: node:22-alpine
              max-time: 10
              artifacts:
                - src/ui/coverage/**
                - src/ui/FE_Tests/**
              script:
                - |
                  echo "Checking develop-test-decision.json..."
                  if [ ! -f "develop-test-decision.json" ]; then
                    echo "No decision file - running all tests"
                    RUN_ALL=true
                  else
                    echo "Decision file contents:"
                    cat develop-test-decision.json
                    echo ""

                    runFrontend=$(grep -o '"runFrontend":[^,}]*' develop-test-decision.json | cut -d':' -f2 | tr -d ' \n\r')
                    if [ "$runFrontend" = "false" ]; then
                      echo "SKIP: No frontend changes detected"
                      exit 0
                    fi

                    isFirstRun=$(grep -o '"isFirstRun":[^,}]*' develop-test-decision.json | cut -d':' -f2 | tr -d ' \n\r')
                    if [ "$isFirstRun" = "true" ]; then
                      echo "First run - will run all tests"
                      RUN_ALL=true
                    else
                      RUN_ALL=false
                      # Extract frontendFiles array from JSON
                      changed_files=$(grep -o '"frontendFiles":\[[^]]*\]' develop-test-decision.json | sed 's/"frontendFiles":\[//;s/\]//;s/"//g;s/,/\n/g' | tr -d ' ')
                      echo "Changed frontend files from decision:"
                      echo "$changed_files"
                    fi
                  fi

                  cd src/ui
                  npm install -g npm@latest
                  cat > .npmrc << EOF
                  registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
                  //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
                  EOF
                  npm ci

                  if [ "$RUN_ALL" = "true" ]; then
                    echo "Running ALL tests"
                    npm run test
                    exit 0
                  fi

                  # ================================================================
                  # DYNAMIC DIRECTORY DISCOVERY FOR SELECTIVE TESTING
                  # ================================================================
                  # Instead of hardcoding directories, we dynamically discover them.
                  # This ensures new directories are automatically included in testing.
                  #
                  # Excluded top-level directories (no testable code):
                  #   assets, middleware, Okta, styles, types, test, pages
                  #   (pages is handled separately to match subdirectories)
                  #
                  # Excluded page directories:
                  #   Dev (developer utilities)
                  # ================================================================

                  # Define excluded directories
                  excluded_top_level="assets|middleware|Okta|styles|types|test|pages"
                  excluded_pages="Dev"

                  # Discover top-level directories (e.g., utils, hooks, components, redux, reduxstore)
                  top_level_dirs=$(ls -d src/ui/src/*/ 2>/dev/null | xargs -n1 basename | grep -Ev "^($excluded_top_level)$" || true)

                  # Discover page directories (e.g., Beneficiaries, Reports, FiscalClose)
                  page_dirs=$(ls -d src/ui/src/pages/*/ 2>/dev/null | xargs -n1 basename | grep -Ev "^($excluded_pages)$" || true)

                  # Build test patterns based on changed areas
                  test_patterns=""

                  # Check top-level directories for changes
                  for dir in $top_level_dirs; do
                    if echo "$changed_files" | grep -q "^src/ui/src/$dir/"; then
                      test_patterns="$test_patterns src/$dir"
                    fi
                  done

                  # Check page directories for changes
                  for page_dir in $page_dirs; do
                    if echo "$changed_files" | grep -q "^src/ui/src/pages/$page_dir/"; then
                      test_patterns="$test_patterns src/pages/$page_dir"
                    fi
                  done

                  # Trim leading whitespace
                  test_patterns=$(echo "$test_patterns" | sed 's/^ *//')

                  if [ -n "$test_patterns" ]; then
                    echo "Running tests for changed areas: $test_patterns"
                    npm run test -- --run $test_patterns
                  else
                    echo "No test areas matched changed files - skipping tests"
                  fi

      # Stage 4: Update the build tag on success
      - step: *update-develop-tag

  # ==========================================================================
  # PULL REQUEST PIPELINE
  # ==========================================================================
  # Runs on all PRs regardless of target branch.
  # Uses Bitbucket's changeset conditions for efficient step skipping.
  #
  # Steps only run if relevant files changed:
  # - Frontend steps: src/ui/**
  # - Backend steps: src/services/**
  #
  # Also includes selective backend analysis for intelligent test targeting.
  # ==========================================================================
  pull-requests:
    "**":
      # Stage 1: Code quality checks (fail fast)
      - step:
          <<: *frontend-lint
          condition:
            changesets:
              includePaths:
                - "src/ui/**/*.ts"
                - "src/ui/**/*.tsx"
                - "src/ui/**/*.js"
                - "src/ui/**/*.jsx"
      # Stage 2: Run audits and security scans only if build succeeds
      - parallel:
          - step:
              <<: *audit-frontend
              condition:
                changesets:
                  includePaths:
                    - "src/ui/**"
          - step:
              <<: *audit-backend
              condition:
                changesets:
                  includePaths:
                    - "src/services/**/*.cs"
                    - "src/services/**/*.csproj"
                    - "src/services/**/*.sln"
                    - "src/services/**/*.slnx"
                    - "src/services/**/*.json"
                    - "src/services/**/*.config"
          - step: *secret-scan
      # Stage 2.5: Selective backend analysis (determines which tests to run)
      - step:
          <<: *selective-backend-analysis
          condition:
            changesets:
              includePaths:
                - "src/services/**/*.cs"
                - "src/services/**/*.csproj"
                - "src/services/**/*.sln"
                - "src/services/**/*.slnx"
                - "src/services/**/*.json"
                - "src/services/**/*.config"
      # Stage 3: Build and test
      - parallel:
          - step:
              <<: *build-and-test-backend
              condition:
                changesets:
                  includePaths:
                    - "src/services/**/*.cs"
                    - "src/services/**/*.csproj"
                    - "src/services/**/*.sln"
                    - "src/services/**/*.slnx"
                    - "src/services/**/*.json"
                    - "src/services/**/*.config"
          - step:
              <<: *test-frontend
              condition:
                changesets:
                  includePaths:
                    - "src/ui/**/*.ts"
                    - "src/ui/**/*.tsx"
                    - "src/ui/**/*.js"
                    - "src/ui/**/*.jsx"

  # ==========================================================================
  # CUSTOM PIPELINES (Manual Trigger)
  # ==========================================================================
  # These pipelines run on-demand from the Bitbucket UI.
  # Select "Run Pipeline" → choose branch → select custom pipeline.
  # ==========================================================================
  custom:
    # ------------------------------------------------------------------------
    # INFRASTRUCTURE AS CODE
    # ------------------------------------------------------------------------
    # Server provisioning: Install .NET hosting bundle, configure IIS settings
    # Variables: ServerEnvironment (QA/UAT), Operation, ForceReinstall
    # ------------------------------------------------------------------------
    infrastructure_as_code:
      - variables:
          - name: ServerEnvironment
            default: QA
            allowed-values:
              - QA
              - UAT
          - name: Operation
            default: install-hosting-bundle
            allowed-values:
              - install-hosting-bundle
              - configure-gzip-compression
          - name: ForceReinstall
            default: "false"
            allowed-values:
              - "true"
              - "false"
      - step:
          name: Execute IaC Operation
          runs-on:
            - windows
            - self.hosted
          script:
            - |
              # Server mapping from centralized definitions (keep in sync with definitions.servers)
              $targetServer = switch ($env:ServerEnvironment) {
                  "QA"  { "appt23d" }
                  "UAT" { "appt24d" }
                  default {
                      Write-Error "Unknown ServerEnvironment: $env:ServerEnvironment (allowed: QA, UAT)"
                      exit 1
                  }
              }

              Write-Host "================================================================" -ForegroundColor Cyan
              Write-Host "  Infrastructure as Code Operation" -ForegroundColor Cyan
              Write-Host "================================================================" -ForegroundColor Cyan
              Write-Host ""
              Write-Host "Environment: $env:ServerEnvironment" -ForegroundColor Yellow
              Write-Host "Target Server: $targetServer" -ForegroundColor Yellow
              Write-Host "Operation: $env:Operation" -ForegroundColor Yellow
              Write-Host "Force Reinstall: $env:ForceReinstall" -ForegroundColor Yellow
              Write-Host ""

              # Execute operation
              switch ($env:Operation) {
                  "install-hosting-bundle" {
                      Write-Host "Installing .NET 10 Hosting Bundle on $targetServer..." -ForegroundColor Cyan
                      
                      $scriptPath = ".\scripts\IaC\Install-DotNetHostingBundle.ps1"
                      if (-not (Test-Path $scriptPath)) {
                          Write-Error "Script not found: $scriptPath"
                          exit 1
                      }

                      # Download the installer locally first (runner has internet access)
                      $downloadUrl = "https://builds.dotnet.microsoft.com/dotnet/aspnetcore/Runtime/10.0.0/dotnet-hosting-10.0.0-win.exe"
                      $localInstallerPath = "$env:TEMP\dotnet-hosting-10.0.0-win.exe"
                      
                      Write-Host "Downloading .NET 10 Hosting Bundle locally..." -ForegroundColor Cyan
                      try {
                          Invoke-WebRequest -Uri $downloadUrl -OutFile $localInstallerPath -ErrorAction Stop
                          $fileSize = (Get-Item $localInstallerPath).Length / 1MB
                          Write-Host "[OK] Downloaded $('{0:N2}' -f $fileSize) MB" -ForegroundColor Green
                      }
                      catch {
                          Write-Error "Failed to download installer: $_"
                          exit 1
                      }

                      # Create remote session (similar to webDeploy.ps1 approach)
                      try {
                          $session = New-PSSession $targetServer
                          
                          # Copy installer and script to remote server temp location
                          $remoteInstallerPath = "C:\temp\dotnet-hosting-10.0.0-win.exe"
                          $remoteScriptPath = "C:\temp\Install-DotNetHostingBundle.ps1"
                          
                          Invoke-Command -Session $session -ScriptBlock {
                              if (-not (Test-Path "C:\temp")) {
                                  New-Item -ItemType Directory -Path "C:\temp" -Force | Out-Null
                              }
                          }
                          
                          Write-Host "Copying files to remote server..." -ForegroundColor Cyan
                          Copy-Item -ToSession $session -Path $localInstallerPath -Destination $remoteInstallerPath -Force
                          Copy-Item -ToSession $session -Path $scriptPath -Destination $remoteScriptPath -Force
                          Write-Host "[OK] Files copied to remote server" -ForegroundColor Green
                          
                          # Execute hosting bundle installation on remote machine
                          $forceFlag = ($env:ForceReinstall -eq 'true')
                          $result = Invoke-Command -Session $session -ScriptBlock {
                              param($Force, $InstallerPath)
                              
                              # Run the installer directly (skip download since we already have the file)
                              Write-Host ""
                              Write-Host "Running .NET 10 Hosting Bundle installer..." -ForegroundColor Cyan
                              
                              try {
                                  $process = Start-Process -FilePath $InstallerPath -ArgumentList "/install", "/quiet", "/norestart" -Wait -PassThru
                                  
                                  if ($process.ExitCode -eq 0) {
                                      Write-Host "[OK] Installation completed successfully (exit code: 0)" -ForegroundColor Green
                                      
                                      # Verify installation
                                      Write-Host ""
                                      Write-Host "Verifying installation..." -ForegroundColor Cyan
                                      $dotnetInfo = & dotnet --info 2>&1 | Out-String
                                      
                                      $hasAspNetCore = $dotnetInfo -match "Microsoft\.AspNetCore\.App 10\.0\.0"
                                      $hasNETCore = $dotnetInfo -match "Microsoft\.NETCore\.App 10\.0\.0"
                                      
                                      if ($hasAspNetCore -and $hasNETCore) {
                                          Write-Host "[OK] .NET 10.0.0 Runtime verified" -ForegroundColor Green
                                          Write-Host "  - Microsoft.AspNetCore.App 10.0.0: Found" -ForegroundColor Green
                                          Write-Host "  - Microsoft.NETCore.App 10.0.0: Found" -ForegroundColor Green
                                      } else {
                                          Write-Host "[!] Verification incomplete" -ForegroundColor Yellow
                                          if ($hasAspNetCore) { Write-Host "  - Microsoft.AspNetCore.App 10.0.0: Found" -ForegroundColor Yellow }
                                          if ($hasNETCore) { Write-Host "  - Microsoft.NETCore.App 10.0.0: Found" -ForegroundColor Yellow }
                                      }
                                      
                                      # Restart IIS
                                      Write-Host ""
                                      Write-Host "Restarting IIS..." -ForegroundColor Cyan
                                      iisreset /restart | Out-Null
                                      Write-Host "[OK] IIS restarted" -ForegroundColor Green
                                      
                                      return 0
                                  } else {
                                      Write-Host "[X] Installation failed with exit code: $($process.ExitCode)" -ForegroundColor Red
                                      return $process.ExitCode
                                  }
                              }
                              catch {
                                  Write-Host "[X] Installation error: $_" -ForegroundColor Red
                                  return 1
                              }
                              finally {
                                  # Cleanup
                                  Remove-Item -Path $InstallerPath -Force -ErrorAction SilentlyContinue
                                  Remove-Item -Path C:\temp\Install-DotNetHostingBundle.ps1 -Force -ErrorAction SilentlyContinue
                              }
                          } -ArgumentList $forceFlag, $remoteInstallerPath
                          
                          if ($result -ne 0) {
                              Write-Error "Hosting bundle installation failed with exit code: $result"
                              exit $result
                          }
                          Write-Host ""
                          Write-Host "[OK] .NET 10 Hosting Bundle installation completed" -ForegroundColor Green
                      }
                      finally {
                          # Cleanup local file
                          Remove-Item -Path $localInstallerPath -Force -ErrorAction SilentlyContinue
                          Remove-PSSession -Session $session -ErrorAction SilentlyContinue
                      }
                  }
                  "configure-gzip-compression" {
                      Write-Host "Configuring IIS Gzip Compression on $targetServer..." -ForegroundColor Cyan
                      
                      $scriptPath = ".\scripts\IaC\IISGzipConfiguration.ps1"
                      if (-not (Test-Path $scriptPath)) {
                          Write-Error "Script not found: $scriptPath"
                          exit 1
                      }

                      # Create remote session (similar to webDeploy.ps1 approach)
                      try {
                          $session = New-PSSession $targetServer
                          
                          # Copy script to remote server temp location
                          $remoteTempPath = "C:\temp\IISGzipConfiguration.ps1"
                          Invoke-Command -Session $session -ScriptBlock {
                              if (-not (Test-Path "C:\temp")) {
                                  New-Item -ItemType Directory -Path "C:\temp" -Force | Out-Null
                              }
                          }
                          Copy-Item -ToSession $session -Path $scriptPath -Destination $remoteTempPath -Force
                          
                          # Execute gzip configuration script on remote machine
                          $result = Invoke-Command -Session $session -ScriptBlock {
                              # Source the script
                              . C:\temp\IISGzipConfiguration.ps1
                              
                              # Run initialization
                              Initialize-IISGzipCompression
                              
                              # Display status
                              Write-Host ""
                              $healthCheck = Test-IISGzipConfigurationHealth
                              
                              # Cleanup
                              Remove-Item -Path C:\temp\IISGzipConfiguration.ps1 -Force -ErrorAction SilentlyContinue
                              
                              # Return health check result
                              return $healthCheck
                          }
                          
                          if (-not $result.IsHealthy) {
                              Write-Warning "Gzip compression configured but health check detected issues"
                              Write-Host "Health check returned: IsHealthy=$($result.IsHealthy)" -ForegroundColor Yellow
                          }
                          Write-Host ""
                          Write-Host "[OK] IIS Gzip Compression configuration completed" -ForegroundColor Green
                      }
                      finally {
                          Remove-PSSession -Session $session -ErrorAction SilentlyContinue
                      }
                  }
                  default {
                      Write-Error "Unknown operation: $env:Operation"
                      exit 1
                  }
              }

              Write-Host ""
              Write-Host "================================================================" -ForegroundColor Cyan
              Write-Host "[OK] IaC operation completed successfully" -ForegroundColor Green
              Write-Host "================================================================" -ForegroundColor Cyan

    # ------------------------------------------------------------------------
    # API LINT
    # ------------------------------------------------------------------------
    # Validate API design against Zalando API Guidelines
    # ------------------------------------------------------------------------
    api_lint:
      - step: *api-lint

    # ------------------------------------------------------------------------
    # DATABASE OPERATIONS
    # ------------------------------------------------------------------------
    # Database management: migrations, reset, data import
    # Variables:
    #   - Environment: QA or UAT
    #   - Action: upgrade-db, drop-recreate-db, import-from-ready, etc.
    #   - SourceSchema: PROFITSHARE or MTPR
    # ------------------------------------------------------------------------
    profitsharing_database:
      - variables: # https://bitbucket.org/blog/predefine-values-of-custom-pipeline-variables
          - name: Environment
            default: QA
            allowed-values:
              - QA
              - UAT
          - name: Action
            default: upgrade-db
            allowed-values:
              - upgrade-db
              - drop-recreate-db
              - import-from-ready
              - import-uat-navigation
              - generate-upgrade-script
              - validate-import
              - full-reset-and-import
          - name: SourceSchema
            default: PROFITSHARE
            allowed-values:
              - PROFITSHARE
              - MTPR
              - PROFITSHARE_STAGING
      - step:
          name: Validate SourceSchema
          script:
            - |
              if [ "$BITBUCKET_PIPELINE_OS" = "windows" ]; then
                pwsh -Command "
                  \$validSchemas = @{
                      'QA'  = @('PROFITSHARE', 'MTPR')
                      'UAT' = @('PROFITSHARE_STAGING')
                  }

                  if (-not \$validSchemas[\$env:Environment] -contains \$env:SourceSchema) {
                      Write-Host 'ERROR: Invalid SourceSchema for selected Environment'
                      Write-Host ('Allowed values for ' + \$env:Environment + ': ' + (\$validSchemas[\$env:Environment] -join ', '))
                      exit 1
                  }

                  Write-Host ('Validated: Environment=' + \$env:Environment + ', SourceSchema=' + \$env:SourceSchema)
                "
              else
                validSchemas_QA=("PROFITSHARE" "MTPR")
                validSchemas_UAT=("PROFITSHARE_STAGING")

                if [ "$Environment" = "QA" ]; then
                  validSchemas=("${validSchemas_QA[@]}")
                elif [ "$Environment" = "UAT" ]; then
                  validSchemas=("${validSchemas_UAT[@]}")
                else
                  echo "ERROR: Unknown Environment '$Environment'"
                  exit 1
                fi

                if [[ ! " ${validSchemas[@]} " =~ " $SourceSchema " ]]; then
                  echo "ERROR: Invalid SourceSchema '$SourceSchema' for Environment '$Environment'"
                  echo "Allowed values: ${validSchemas[*]}"
                  exit 1
                fi

                echo "Validated: Environment=$Environment, SourceSchema=$SourceSchema"
              fi
      - step: *upgrade-database

    # ------------------------------------------------------------------------
    # END-TO-END TESTS (Playwright)
    # ------------------------------------------------------------------------
    # Run Playwright E2E tests against QA environment
    # Uses QA_Playwright variable for credentials
    # ------------------------------------------------------------------------
    playwright_e2e_qa:
      - step: *run-playwright-tests
