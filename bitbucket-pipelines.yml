# ------------------------------------------------------------------------
# BitBucket Pipeline
# ------------------------------------------------------------------------
# Application Name:
#   - SMART Profit Sharing
# ------------------------------------------------------------------------

definitions:
  # Centralized server variables
  servers:
    qa_app_server: &qa_app_server "appt23d"
    uat_app_server: &uat_app_server "appt24d"

  steps:
    build-and-test-backend: &build-and-test-backend
      name: Build and Test Backend API
      runs-on:
        - windows
        - self.hosted
      script:
        # Set environment variables
        - $env:NUGET_ORG = "https://api.nuget.org/v3/index.json"
        - $env:TEST_PROJECT_NAME = "Demoulas.ProfitSharing.UnitTests"
        - $env:REPORTS_PATH = "../../../../test-reports/build_${BITBUCKET_BUILD_NUMBER}"

        # Ensure the REPORTS_PATH directory exists
        - mkdir -Force -Path $env:REPORTS_PATH

        # Verify required .NET SDK is available (do not attempt installation)
        - echo "Checking for required .NET SDK version..."
        - |
          $dotnetSdkList = dotnet --list-sdks;
          Write-Output "Installed .NET SDKs:";
          Write-Output $dotnetSdkList;
          
          $dotnetSdkRequired = $dotnetSdkList | Select-String "^10\.";
          if (-not $dotnetSdkRequired) {
              Write-Error "FAILED: .NET 10 SDK is required but not available.";
              Write-Error "Please ensure .NET 10 SDK is installed on the build agent.";
              exit 1;
          }

        # Clean any previous build artifacts to ensure deterministic builds
        - echo "Cleaning previous build artifacts..."
        - dotnet clean src/services/Demoulas.ProfitSharing.slnx --configuration Release

        # Restore packages explicitly
        - echo "Restoring NuGet packages..."
        - dotnet restore src/services/Demoulas.ProfitSharing.slnx -p:RestoreAdditionalProjectSources=$env:NUGET_ORG

        # Build without incremental compilation to avoid stale artifacts
        - echo "Building solution..."
        - dotnet build src/services/Demoulas.ProfitSharing.slnx --configuration Release --no-incremental --no-restore

        # Run tests against the fresh build
        - echo "Running unit tests..."
        - dotnet test src/services/tests/Demoulas.ProfitSharing.UnitTests/{$env:TEST_PROJECT_NAME}.csproj --configuration Release --no-build --logger:"junit;LogFilePath={$env:REPORTS_PATH}/junit.xml"

      artifacts:
        - test-reports/**
    
    test-frontend: &test-frontend
      name: Build and Test Frontend UI
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      artifacts:
        - src/ui/coverage/**
        - src/ui/FE_Tests/**
      script:
        - cd src/ui
        - echo "Running frontend tests on cloud runner..."
        
        # Update npm to latest version
        - npm install -g npm@latest
        
        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        
        # Install dependencies and run tests
        - npm ci
        - npm run test
   
    generate-buildinfo: &generate-buildinfo
      name: Generate Build Information
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - .buildinfo.json
      script:
        - dotnet tool update --global Demoulas.Common.Build.Cli --no-cache
        - Demoulas.Common.Build.Cli --buildid ${env:BITBUCKET_BUILD_NUMBER} --Branch ${env:BITBUCKET_BRANCH} --CommitHash ${env:BITBUCKET_COMMIT}
        - if (!(Test-Path ".buildinfo.json")) { Write-Error "Failed to generate .buildinfo.json"; exit 1; }
    
    create-api-artifacts: &create-api-artifacts
      name: Create API Artifacts
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        # Only update the specific tool we need, not all tools globally
        - dotnet tool update --global Demoulas.Common.Build.Cli --no-cache
        - Write-Host ${env:BITBUCKET_BUILD_NUMBER}
        - Write-Host ${env:BITBUCKET_BRANCH}
        - Write-Host ${env:BITBUCKET_COMMIT}
        - Write-Host $(Get-Location)
        - Write-Host $(Get-ChildItem)
        - New-Item -ItemType Directory -Path "dist"

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.Api -c Release -p:PublishProfile=FolderProfile -o .\publishOutput
        
        - Demoulas.Common.Build.Cli --buildid ${env:BITBUCKET_BUILD_NUMBER} --Branch ${env:BITBUCKET_BRANCH} --CommitHash ${env:BITBUCKET_COMMIT}
        - Copy-Item -Path ".buildinfo.json" -Destination ".\publishOutput\"
        
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.Api.zip -Force

    create-service-artifacts: &create-service-artifacts
      name: Create Background Service Artifacts
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        - $env:NUGET_ORG = "https://api.nuget.org/v3/index.json"
        - Write-Host $(Get-Location)
        - Write-Host $(Get-ChildItem)
        - New-Item -ItemType Directory -Path "dist"
        
        # Tool already updated in create-api-artifacts step (runs in parallel)
        # Only update if not already present
        - if (-not (Get-Command Demoulas.Common.Build.Cli -ErrorAction SilentlyContinue)) { dotnet tool update --global Demoulas.Common.Build.Cli --no-cache }

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeeFull.Sync -c Release -p:RestoreAdditionalProjectSources=$env:NUGET_ORG -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeeFull.Sync.zip -Force

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeeDelta.Sync -c Release -p:RestoreAdditionalProjectSources=$env:NUGET_ORG -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeeDelta.Sync.zip -Force

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeePayroll.Sync -c Release -p:RestoreAdditionalProjectSources=$env:NUGET_ORG -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeePayroll.Sync.zip -Force

    create-frontend-artifact-qa: &create-frontend-artifact-qa
      name: Create FrontEnd Artifacts (QA)
      # Run on cloud to free on-premises resources
      image: node:22-alpine
      artifacts:
        - dist/**
      script:
        # Navigate to UI directory
        - cd src/ui
        
        # Install zip utility and update npm
        - apk add --no-cache zip
        - npm install -g npm@latest
        
        # Create .npmrc for JFrog access (using bash heredoc syntax)
        - |
          cat > .npmrc << 'EOF'
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        
        # Update package.json version from .buildinfo.json
        - |
          if [ -f ../../.buildinfo.json ]; then
            BUILD_NUMBER=$(grep -o '"buildNumber":"[^"]*"' ../../.buildinfo.json | cut -d'"' -f4)
            BUILD_ID=$(grep -o '"buildId":[0-9]*' ../../.buildinfo.json | cut -d':' -f2)
            if [ -n "$BUILD_NUMBER" ] && [ -n "$BUILD_ID" ]; then
              # Parse BUILD_NUMBER as YYYYmmDD and convert to YYYY.mmDD
              if [ ${#BUILD_NUMBER} -eq 8 ]; then
                YEAR="${BUILD_NUMBER:0:4}"
                MONTH="${BUILD_NUMBER:4:2}"
                DAY="${BUILD_NUMBER:6:2}"
                SEMANTIC_VERSION="${YEAR}.${MONTH}${DAY}.${BUILD_ID}"
              else
                # Fallback if format is unexpected
                SEMANTIC_VERSION="${BUILD_NUMBER}.${BUILD_ID}"
              fi
              node -e "const pkg=require('./package.json'); pkg.version='${SEMANTIC_VERSION}'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');"
              echo "✓ Updated package.json version to $SEMANTIC_VERSION"
              grep '"version"' package.json
            fi
          fi
        
        # Copy buildinfo.json from artifact to public directory
        - echo "Copying .buildinfo.json from artifact..."
        - cp ../../.buildinfo.json ./public/.buildinfo.json
        - echo "✓ Build info copied to public directory"
        - cat ./public/.buildinfo.json
        
        # Install dependencies
        - npm ci
        
        # Build for QA environment
        - npm run build:qa
        
        # Create dist directory at repo root
        - mkdir -p ../../dist
        
        # Package artifact using zip
        - cd build
        - zip -r ../../../dist/Demoulas.ProfitSharing.UI.qa.zip .
        - cd ..
        
        # Verify artifact was created
        - ls -lh ../../dist/Demoulas.ProfitSharing.UI.qa.zip
        - echo "✓ QA artifact created successfully"
        

    create-frontend-artifact-uat: &create-frontend-artifact-uat
      name: Create FrontEnd Artifacts (UAT)
      # Run on cloud to free on-premises resources
      image: node:22-alpine
      artifacts:
        - dist/**
      script:
        # Navigate to UI directory
        - cd src/ui
        
        # Install zip utility and update npm
        - apk add --no-cache zip
        - npm install -g npm@latest
        
        # Create .npmrc for JFrog access (using bash heredoc syntax)
        - |
          cat > .npmrc << 'EOF'
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        
        # Update package.json version from .buildinfo.json
        - |
          if [ -f ../../.buildinfo.json ]; then
            BUILD_NUMBER=$(grep -o '"buildNumber":"[^"]*"' ../../.buildinfo.json | cut -d'"' -f4)
            BUILD_ID=$(grep -o '"buildId":[0-9]*' ../../.buildinfo.json | cut -d':' -f2)
            if [ -n "$BUILD_NUMBER" ] && [ -n "$BUILD_ID" ]; then
              # Parse BUILD_NUMBER as YYYYmmDD and convert to YYYY.mmDD
              if [ ${#BUILD_NUMBER} -eq 8 ]; then
                YEAR="${BUILD_NUMBER:0:4}"
                MONTH="${BUILD_NUMBER:4:2}"
                DAY="${BUILD_NUMBER:6:2}"
                SEMANTIC_VERSION="${YEAR}.${MONTH}${DAY}.${BUILD_ID}"
              else
                # Fallback if format is unexpected
                SEMANTIC_VERSION="${BUILD_NUMBER}.${BUILD_ID}"
              fi
              node -e "const pkg=require('./package.json'); pkg.version='${SEMANTIC_VERSION}'; require('fs').writeFileSync('./package.json', JSON.stringify(pkg, null, 2) + '\n');"
              echo "✓ Updated package.json version to $SEMANTIC_VERSION"
              grep '"version"' package.json
            fi
          fi
        
        # Copy buildinfo.json from artifact to public directory
        - echo "Copying .buildinfo.json from artifact..."
        - cp ../../.buildinfo.json ./public/.buildinfo.json
        - echo "✓ Build info copied to public directory"
        - cat ./public/.buildinfo.json
        
        # Install dependencies
        - npm ci
        
        # Build for UAT environment
        - npm run build:uat
        
        # Create dist directory at repo root
        - mkdir -p ../../dist
        
        # Package artifact using zip
        - cd build
        - zip -r ../../../dist/Demoulas.ProfitSharing.UI.uat.zip .
        - cd ..
        
        # Verify artifact was created
        - ls -lh ../../dist/Demoulas.ProfitSharing.UI.uat.zip
        - echo "✓ UAT artifact created successfully"


    upgrade-database: &upgrade-database
      name: Upgrade Database
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        - |
          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\output
          if ($LASTEXITCODE -ne 0) { Write-Error "Database project build failed. Exiting."; exit 1 }

          $environment = $env:Environment
          $action = $env:Action
          $sourceSchema = $env:SourceSchema
          $currentYear = $env:CurrentYear

          if (-not $environment) { $environment = "QA" }
          if (-not $action) { $action = "upgrade-db" }
          if (-not $sourceSchema) { $sourceSchema = "PROFITSHARE" }
          if (-not $currentYear) { $currentYear = "2024" }

          if ($environment -eq "QA") {
            $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_QA            
          }

          if ($environment -eq "UAT") {
            $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT            
          }

          if (-not $sourceSchema) {
            Write-Error "Source schema is undefined. Exiting."; exit 1
          }

          Write-Host "Running database upgrade with action: $action"
          Write-Host "Target environment: $environment"
          Write-Host "Source schema: $sourceSchema"
          Write-Host "Current directory: $(Get-Location)"

          # -------------------------------------------------------------
          # Full Reset & Import (Nuclear-Option parity)
          #   Action: full-reset-and-import
          #   Steps: drop-recreate-db -> import-from-ready -> import-from-navigation
          # -------------------------------------------------------------
          if ($action -eq "full-reset-and-import") {
            if ($environment -ne "QA") {
              Write-Error "Action 'full-reset-and-import' is restricted to QA environment only. Current environment: $environment"; exit 1
            }
            Write-Host "[Full Reset] Dropping & recreating schema $sourceSchema"
            .\output\Demoulas.ProfitSharing.Data.Cli drop-recreate-db --connection-name ProfitSharing --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Drop/Recreate failed. Exiting"; exit 1 }

            Write-Host "[Full Reset] Importing from READY into $sourceSchema"
            .\output\Demoulas.ProfitSharing.Data.Cli import-from-ready --connection-name ProfitSharing --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Import from READY failed. Exiting"; exit 1 }

            $navigationFile = ".\src\database\ready_import\Navigations\add-navigation-data.sql"
            if ($environment -eq "UAT") {
              $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
              Write-Host "[Full Reset] Using UAT navigation data"
            }

            Write-Host "[Full Reset] Importing navigation data from $navigationFile"
            .\output\Demoulas.ProfitSharing.Data.Cli import-from-navigation --connection-name ProfitSharing --sql-file $navigationFile --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Navigation import failed. Exiting"; exit 1 }

            Write-Host "[Full Reset] Completed successfully."
            exit 0
          }

          .\output\Demoulas.ProfitSharing.Data.Cli $action --connection-name ProfitSharing --output-file ".\dist\migration.sql" --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $sourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Database upgrade failed. Exiting"; exit 1 }

          # Determine which navigation file to use based on action or environment
          $navigationFile = ".\src\database\ready_import\Navigations\add-navigation-data.sql"
          if ($action -eq "import-uat-navigation" -or $environment -eq "UAT") {
            $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
            Write-Host "Using UAT navigation data"
          }

          .\output\Demoulas.ProfitSharing.Data.Cli import-from-navigation  --connection-name ProfitSharing --output-file ".\dist\navigations.sql" --sql-file $navigationFile --source-schema $sourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Database upgrade failed. Exiting"; exit 1 }

          if ($action -eq "validate-import") {
            .\output\Demoulas.ProfitSharing.Data.Cli validate-import --connection-name ProfitSharing --sql-file ".\src\database\ready_import\Import Validations.sql" --source-schema $sourceSchema --current-year $currentYear
            if ($LASTEXITCODE -ne 0) { Write-Error "Database import validation failed. Exiting"; exit 1 }
          }
          

    uat-drop-recreate-db: &uat-drop-recreate-db
      name: UAT Drop & Recreate DB
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:Action = "drop-recreate-db"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          Write-Host "Dropping & recreating UAT database (schema: $env:SourceSchema)"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli $env:Action --connection-name ProfitSharing --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Drop/Recreate failed."; exit 1 }
          Write-Host "Drop & recreate completed."

    uat-import-from-ready: &uat-import-from-ready
      name: UAT Import From READY
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:Action = "import-from-ready"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          Write-Host "Importing data from READY into UAT schema: $env:SourceSchema"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli $env:Action --connection-name ProfitSharing --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Import from READY failed."; exit 1 }
          Write-Host "Import from READY completed."

    uat-import-uat-navigation: &uat-import-uat-navigation
      name: UAT Import Navigation Data
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
          Write-Host "Importing UAT navigation data using $navigationFile"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli import-from-navigation --connection-name ProfitSharing --sql-file $navigationFile --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Navigation import failed."; exit 1 }
          Write-Host "Navigation import completed."

    uat-validate-import: &uat-validate-import
      name: UAT Validate Import
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          $currentYear = (Get-Date).Year

          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\output
          if ($LASTEXITCODE -ne 0) { Write-Error "Database project build failed. Exiting."; exit 1 }

          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }

          Write-Host "Validating UAT import for schema $env:SourceSchema and year $currentYear"
          .\output\Demoulas.ProfitSharing.Data.Cli validate-import --connection-name ProfitSharing --sql-file ".\src\database\ready_import\Import Validations.sql" --source-schema $env:SourceSchema --current-year $currentYear
          if ($LASTEXITCODE -ne 0) { Write-Error "Import validation failed."; exit 1 }
          Write-Host "Import validation completed."

    db-cli-build-artifact: &db-cli-build-artifact
      name: Build DB CLI (artifact)
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dbcli/**
      script:
        - |
          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\dbcli
          if ($LASTEXITCODE -ne 0) { Write-Error "Database CLI build failed. Exiting."; exit 1 }
          Write-Host "DB CLI built to .\\dbcli"

    audit-backend: &audit-backend
      name: "Check Backend API for vulnerabilities"
      runs-on:
        - windows
        - self.hosted
      script:
        - $env:SolutionDir = ".\src\services"
        - echo "Checking dotnet vulnerabilities"
        - cd $env:SolutionDir

        - dotnet --info
        - dotnet nuget list source
        - dotnet workload update --source https://api.nuget.org/v3/index.json
        - dotnet workload install aspire --source https://api.nuget.org/v3/index.json
        - dotnet restore Demoulas.ProfitSharing.slnx -p:RestoreAdditionalProjectSources=https://api.nuget.org/v3/index.json


        - |
          $output = dotnet list Demoulas.ProfitSharing.slnx package --vulnerable --include-transitive --source https://api.nuget.org/v3/index.json
          if ($output -match "has the following vulnerable packages") {
            Write-Host "Vulnerabilities found!"
            Write-Host $output
            exit 1
          } else {
            Write-Host "No vulnerabilities found."
            exit 0
          }        


    audit-frontend: &audit-frontend
      name: "Check frontend for vulnerabilities"
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      script:
        - cd src/ui
        - echo "Checking npm vulnerabilities on cloud runner..."
        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        - npm audit --audit-level=high --production
    
    frontend-lint: &frontend-lint
      name: Frontend Lint
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      script:
        - cd src/ui
        - echo "Running frontend linting on cloud runner..."

        # Update npm to latest version
        - npm install -g npm@latest

        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF

        # Install dependencies and run linting
        - npm ci
        - npm run lint

    secret-scan: &secret-scan
      name: "Secret scan (Gitleaks)"
      # Runs on Bitbucket Cloud by default (Docker image)
      image: zricethezav/gitleaks:latest
      max-time: 5
      artifacts:
        - reports/**
      script:
        - mkdir -p reports
        - gitleaks detect --source . --config gitleaks.toml --redact --no-banner --report-format json --report-path reports/gitleaks.json --exit-code 0
        - echo "Gitleaks findings (redacted JSON):"
        - head -c 200000 reports/gitleaks.json || true
        - |
          # Robust leak evaluation without python dependency
          if [ ! -s reports/gitleaks.json ]; then
            echo "No leaks found (empty report).";
          else
            if command -v jq >/dev/null 2>&1; then
              findings_count=$(jq 'if type=="array" then length elif (.findings|type? == "array") then (.findings|length) else 0 end' reports/gitleaks.json 2>/dev/null || echo 0)
            else
              # Fallback: treat literal [] or [ ] as zero, anything else non-empty as 1
              if grep -q '"Description"' reports/gitleaks.json; then
                # Some formats include fields; attempt crude count of occurrences of "RuleID"
                findings_count=$(grep -o '"RuleID"' reports/gitleaks.json | wc -l | tr -d ' ')
              elif grep -Eq '^\s*\[\s*\]\s*$' reports/gitleaks.json; then
                findings_count=0
              else
                # Non-empty & not literal empty array: assume at least 1
                findings_count=1
              fi
            fi
            echo "Gitleaks findings count: $findings_count"
            if [ "${findings_count}" -gt 0 ]; then
              echo "Leaks found. Failing the build.";
              exit 1;
            else
              echo "No leaks found.";
            fi
          fi
    run-playwright-tests: &run-playwright-tests
      name: "Run Playwright E2E Tests (QA)"
      runs-on:
        - windows
        - self.hosted
        - volta
      artifacts:
        - ui/playwright-report/**
        - ui/test-results/**
        - src/UI/playwright-report/**
        - src/UI/test-results/**
        - playwright-artifacts/**
      script:
        - |
          <#
            Playwright E2E Runner (QA)
            Sections:
              1) Locate project dir
              2) Ensure Node version (Volta)
              3) Materialize .env from QA_Playwright variable
              4) Install deps & browsers
              5) Execute tests (JUnit + HTML)
              6) Collect artifacts & set exit code
          #>

          Write-Host "[1] Locate Playwright project directory" -ForegroundColor Cyan
          $candidateDirs = @('ui','src/UI','src/ui')
          $playwrightDir = $candidateDirs | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $playwrightDir) { Write-Error "Playwright project directory not found. Checked: $($candidateDirs -join ', ')"; exit 1 }
          Set-Location $playwrightDir
          Write-Host "Using directory: $playwrightDir"

          Write-Host "[2] Ensure compatible Node.js version" -ForegroundColor Cyan
          $targetNode = '22.16.0'
          try { $currentNode = (node -v) 2>$null } catch { $currentNode = 'unknown' }
          Write-Host "Current node: $currentNode"
          if (Get-Command volta -ErrorAction SilentlyContinue) {
            volta install node@$targetNode | Out-Null
            Write-Host "Node after install: $(node -v)"
          } else {
            Write-Host "Volta unavailable; proceeding with existing Node version" -ForegroundColor Yellow
          }

          Write-Host "[3] Build .env from QA_Playwright variable" -ForegroundColor Cyan
          if (-not $env:QA_Playwright) { Write-Error "QA_Playwright variable not set"; exit 1 }
          $raw = $env:QA_Playwright
          # Tokenize by whitespace; handle patterns like KEY=value and KEY= value
          $parts = $raw -split '\s+' | Where-Object { $_ -and ($_ -notmatch '^\s*$') }
          $kv = @{}
          for ($i = 0; $i -lt $parts.Length; $i++) {
            $p = $parts[$i]
            if ($p -match '^([A-Za-z_][A-Za-z0-9_]*)=(.*)$') {
              $k = $matches[1]
              $v = $matches[2]
              if ($v -eq '') {
                # Value may be next token (e.g. USER_NAME= rharding)
                if ($i + 1 -lt $parts.Length -and ($parts[$i+1] -notmatch '^[A-Za-z_][A-Za-z0-9_]*=')) {
                  $v = $parts[$i+1]
                  $i++
                }
              }
              $v = $v.Trim().Trim('"').Trim("'")
              if (-not $kv.ContainsKey($k)) { $kv[$k] = $v }
            }
          }
          $userKey = ($kv.Keys | Where-Object { $_ -in 'USER_NAME','USERNAME','USER','LOGIN' } | Select-Object -First 1)
          $passKey = ($kv.Keys | Where-Object { $_ -in 'PASSWORD','PASS','PWD' } | Select-Object -First 1)
          $userVal = if ($userKey) { $kv[$userKey] } else { '' }
          $passVal = if ($passKey) { $kv[$passKey] } else { '' }
          $ciVal = if ($kv.ContainsKey('CI')) { $kv['CI'] } else { '' }
          $qaVal = if ($kv.ContainsKey('QA')) { $kv['QA'] } else { '' }
          if (-not $userVal -or -not $passVal) {
            Write-Host 'Parsed keys (no secrets): ' + ($kv.Keys -join ', ')
            Write-Error 'Missing USER credential (USER_NAME/USERNAME/USER/LOGIN) and/or PASSWORD (PASSWORD/PASS/PWD) in QA_Playwright value.'; exit 1
          }
          $lines = @(
            "CI=$ciVal",
            "QA=$qaVal",
            "USER_NAME=$userVal",
            "PASSWORD=$passVal"
          )
          Set-Content ./.env -Value $lines
          Write-Host ".env keys emitted: CI, QA, USER_NAME, PASSWORD"
          # Some configs expect a .playwright.env specifically; create it if not present
          Copy-Item ./.env ./.playwright.env -Force

          Write-Host "[4] Install dependencies & browsers" -ForegroundColor Cyan
          if (Test-Path node_modules) { Remove-Item -Recurse -Force node_modules }
          npm ci
          npx playwright install --with-deps; if ($LASTEXITCODE -ne 0) { npx playwright install }

          Write-Host "[5] Run tests" -ForegroundColor Cyan
          New-Item -ItemType Directory -Path test-results -Force | Out-Null

          # Diagnostic: show any duplicate playwright test packages
          Get-ChildItem -Path node_modules -Filter playwright -Recurse -Depth 3 -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object { Write-Host "Found playwright path: $($_.FullName)" }
          Get-ChildItem -Path node_modules -Filter "@playwright" -Recurse -Depth 5 -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object { Write-Host "Found @playwright path: $($_.FullName)" }
          # Use direct CLI to avoid potential global 'playwright' package ambiguity
          $playwrightCli = Join-Path (Resolve-Path ./node_modules/@playwright/test).Path "cli.js"
          if (-not (Test-Path $playwrightCli)) { Write-Error "Playwright CLI not found at $playwrightCli"; Get-ChildItem node_modules/@playwright/test -Recurse -Depth 2; exit 1 }
          node $playwrightCli test --reporter "list,junit" --config=playwright.config.ts --output=test-results --workers=1
          $pwExit = $LASTEXITCODE

          Write-Host "[6] Prepare Bitbucket test-reports ingestion" -ForegroundColor Cyan
          $repoRoot = $env:BITBUCKET_CLONE_DIR; if (-not $repoRoot) { $repoRoot = (Resolve-Path '..').Path }
          $bbTestRoot = Join-Path $repoRoot 'test-reports'
          $bbPlaywrightDir = Join-Path $bbTestRoot 'playwright'
          if (!(Test-Path $bbPlaywrightDir)) { New-Item -ItemType Directory -Path $bbPlaywrightDir -Force | Out-Null }
          # Locate a junit xml (reporter names can vary). Prefer explicit junit.xml if present.
          $junitCandidate = @(
            Get-ChildItem -Path test-results -Recurse -Filter junit*.xml -ErrorAction SilentlyContinue
            Get-ChildItem -Path test-results -Recurse -Filter *.xml -ErrorAction SilentlyContinue | Where-Object { (Get-Content $_.FullName -TotalCount 5) -match '<testsuite' }
          ) | Where-Object { $_ } | Select-Object -First 1
          if ($junitCandidate) {
            Copy-Item $junitCandidate.FullName (Join-Path $bbPlaywrightDir 'junit.xml') -Force
            Write-Host "Copied JUnit report to test-reports/playwright/junit.xml"
          } else {
            Write-Host "No JUnit XML found to copy." -ForegroundColor Yellow
          }

          Write-Host "[7] Collect artifacts" -ForegroundColor Cyan
          $artifactRoot = Join-Path $repoRoot 'playwright-artifacts'
            if (!(Test-Path $artifactRoot)) { New-Item -ItemType Directory -Path $artifactRoot | Out-Null }
          foreach ($d in 'playwright-report','test-results') { if (Test-Path $d) { Copy-Item -Recurse -Force $d (Join-Path $artifactRoot $d) } }

          Write-Host "[8] Finalize with exit code $pwExit" -ForegroundColor Cyan
          exit $pwExit

    create-release-tag: &create-release-tag
      name: Create Release Tag
      script:
        - |
          echo "Reading build information..."
          if [ ! -f ".buildinfo.json" ]; then
            echo "Error: .buildinfo.json not found"
            exit 1
          fi
          
          # Parse buildNumber and buildId from JSON
          BUILD_NUMBER=$(grep -o '"buildNumber":"[^"]*"' .buildinfo.json | cut -d'"' -f4)
          BUILD_ID=$(grep -o '"buildId":[0-9]*' .buildinfo.json | cut -d':' -f2)
          
          if [ -z "$BUILD_NUMBER" ] || [ -z "$BUILD_ID" ]; then
            echo "Error: Could not parse buildNumber or buildId from .buildinfo.json"
            cat .buildinfo.json
            exit 1
          fi
          
          TAG_NAME="${BUILD_NUMBER}.${BUILD_ID}"
          TAG_MESSAGE="Release build ${BUILD_NUMBER}.${BUILD_ID} deployed to QA"
          
          echo "Creating release tag: $TAG_NAME"
          echo "Message: $TAG_MESSAGE"
          
          git config user.email "bitbucket-pipeline@demoulas.com"
          git config user.name "Bitbucket Pipeline"
          
          # Check if tag already exists
          if git tag -l | grep -q "^${TAG_NAME}$"; then
            echo "Warning: Tag '$TAG_NAME' already exists locally. Skipping tag creation."
            exit 0
          fi
          
          if git ls-remote --tags origin | grep -q "refs/tags/${TAG_NAME}$"; then
            echo "Warning: Tag '$TAG_NAME' already exists on remote. Skipping tag creation."
            exit 0
          fi
          
          # Create and push tag
          git tag -a "$TAG_NAME" -m "$TAG_MESSAGE"
          git push origin "refs/tags/$TAG_NAME"
          
          echo "✓ Release tag '$TAG_NAME' created and pushed successfully"
          

pipelines:
  branches:
    release:
      # Stage 1: Build and test
      - parallel:
          - step: *build-and-test-backend
          - step: *test-frontend
          - step: *audit-frontend
          - step: *audit-backend
      # Stage 2: Generate build information (Windows, ~30 seconds)
      - step: *generate-buildinfo
      # Stage 3: Create artifacts (API/services on Windows, UI builds in parallel on cloud)
      - parallel:
          - step: *create-api-artifacts
          - step: *create-service-artifacts
          - step: *create-frontend-artifact-qa
          - step: *db-cli-build-artifact
      # Stage 4: QA Deployment
      - step:
          name: "Application Deployment (QA)"
          runs-on:
            - windows
            - self.hosted
          deployment: QA
          trigger: "manual"
          script:
            - $env:ENV = "QA"
            - $env:API_SERVER_QA = *qa_app_server
            - |
              try {
                pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/EmployeeDelta'
                pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/EmployeeFull'
                pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/Payroll'
                pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/inetpub/wwwroot/api'
                Write-Host "Deploying web application..." -ForegroundColor Cyan
                $env:API_ARTIFACT_NAME = "Demoulas.ProfitSharing.Api.zip"
                $env:UI_ARTIFACT_NAME = "Demoulas.ProfitSharing.UI.QA.zip"
                pwsh .\scripts\webDeploy.ps1 $env:ENV $env:API_SERVER_QA $env:API_ARTIFACT_NAME $env:UI_ARTIFACT_NAME
                Write-Host "Deploying background service..." -ForegroundColor Cyan
                pwsh .\scripts\servicesDeploy.ps1 ${env:ENV} $env:API_SERVER_QA
                Write-Host "QA deployment completed successfully" -ForegroundColor Green
                pwsh .\scripts\Notify-Teams.ps1 -Status SUCCESS -Environment QA -Step Deployment
              }
              catch {
                $env:DEPLOY_ERROR = $_.Exception.Message
                Write-Host "QA deployment failed" -ForegroundColor Red
                pwsh .\scripts\Notify-Teams.ps1 -Status FAILURE -Environment QA -Step Deployment -ErrorMessage $env:DEPLOY_ERROR
                exit 1
              }
      - step: *upgrade-database
  
      - step:
          name: "Checking API Health"
          runs-on:
            - windows
            - self.hosted
          script:
            - |
              $env:API_SERVER_QA = *qa_app_server
              try {
                pwsh -File ./scripts/Check-Health.ps1 -Url $env:QA_BASE_URL -envServerName $env:API_SERVER_QA
                Write-Host "API health check passed" -ForegroundColor Green
              }
              catch {
                Write-Host "API health check failed" -ForegroundColor Red
                pwsh .\scripts\Notify-Teams.ps1 -Status FAILURE -Environment QA -Step HealthCheck -ErrorMessage $_.Exception.Message
                exit 1
              }

      # Stage 5: Create Release Tag
      - step: *create-release-tag

      # Stage 6: UAT Promotion Gate
      - step:
          name: "Gate: Promote to UAT"
          runs-on:
            - windows
            - self.hosted
          trigger: "manual"
          script:
            - echo "Manual approval granted. Continuing to UAT deployment & data operations."
            - |
              Write-Host "Release context:"
              Write-Host ("  Build: " + $env:BITBUCKET_BUILD_NUMBER)
              Write-Host ("  Branch: " + $env:BITBUCKET_BRANCH)
              Write-Host ("  Commit: " + $env:BITBUCKET_COMMIT)
              Write-Host ("  QA API: " + $env:QA_BASE_URL)
              Write-Host "Artifacts in ./dist:"
              if (Test-Path .\dist) {
                Get-ChildItem -Recurse -File .\dist | ForEach-Object {
                  "{0,10} bytes  {1}" -f $_.Length, $_.FullName
                }
              } else {
                Write-Host "  (no dist folder found)"
              }
              Write-Host "Planned UAT sequence:"
              Write-Host "  1) Drop & Recreate DB (parallel with app deploy)"
              Write-Host "  2) App deploy + Import from READY (reusing artifacts from Stage 3)"
              Write-Host "  3) Import UAT navigation"
              Write-Host "  4) Parallel: Validate import + UAT API health check"

      - step: *create-frontend-artifact-uat
      # Stage 7: UAT Deployment (reuses artifacts from Stage 3)
      - parallel:
          - step: *uat-drop-recreate-db
          - step:
              name: "Application Deployment UAT"
              runs-on:
                - windows
                - self.hosted
              deployment: UAT
              script:
                - |
                  try {
                    Write-Host "Deploying application to UAT (reusing API artifact from Stage 2)..." -ForegroundColor Cyan
                    $env:API_SERVER_UAT = *uat_app_server
                    $env:ENV = "UAT"
                    pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/EmployeeDelta'
                    pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/EmployeeFull'
                    pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/Payroll'
                    pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/inetpub/wwwroot/api'
                    Write-Host "Deploying web application..." -ForegroundColor Cyan
                    $env:API_ARTIFACT_NAME = "Demoulas.ProfitSharing.Api.zip"
                    $env:UI_ARTIFACT_NAME = "Demoulas.ProfitSharing.UI.UAT.zip"
                    pwsh .\scripts\webDeploy.ps1 $env:ENV $env:API_SERVER_UAT $env:API_ARTIFACT_NAME $env:UI_ARTIFACT_NAME
                    Write-Host "Deploying background service..." -ForegroundColor Cyan
                    pwsh .\scripts\servicesDeploy.ps1 ${env:ENV} $env:API_SERVER_UAT
                    Write-Host "UAT deployment completed successfully" -ForegroundColor Green
                    pwsh .\scripts\Notify-Teams.ps1 -Status SUCCESS -Environment UAT -Step Deployment
                  }
                  catch {
                    $env:DEPLOY_ERROR = $_.Exception.Message
                    Write-Host "UAT deployment failed" -ForegroundColor Red
                    pwsh .\scripts\Notify-Teams.ps1 -Status FAILURE -Environment UAT -Step Deployment -ErrorMessage $env:DEPLOY_ERROR
                    exit 1
                  }
      # Stage 6: UAT Database Import (must run AFTER drop-recreate completes)
      - step: *uat-import-from-ready
      - step: *uat-import-uat-navigation
      - step: *uat-validate-import


    develop:
      - parallel:
          - step: *build-and-test-backend
          - step: *test-frontend
          - step: *audit-frontend
          - step: *audit-backend


  pull-requests:
    '**':
      # Stage 1: Code quality checks (fail fast)
      - step: *frontend-lint
      # Stage 2: Build and test
      - parallel:
          - step: *build-and-test-backend
          - step: *test-frontend
      # Stage 3: Run audits and security scans only if build succeeds
      - parallel:
          - step: *audit-frontend
          - step: *audit-backend
          - step: *secret-scan
  
  custom:
    infrastructure_as_code:
      - variables:
          - name: ServerEnvironment
            default: QA
            allowed-values:
              - QA
              - UAT
          - name: Operation
            default: install-hosting-bundle
            allowed-values:
              - install-hosting-bundle
              - configure-gzip-compression
          - name: ForceReinstall
            default: 'false'
            allowed-values:
              - 'true'
              - 'false'
      - step:
          name: Execute IaC Operation
          runs-on:
            - windows
            - self.hosted
          script:
            - |
              # Server mapping from centralized definitions (keep in sync with definitions.servers)
              $targetServer = switch ($env:ServerEnvironment) {
                  "QA"  { "appt23d" }
                  "UAT" { "appt24d" }
                  default {
                      Write-Error "Unknown ServerEnvironment: $env:ServerEnvironment (allowed: QA, UAT)"
                      exit 1
                  }
              }

              Write-Host "================================================================" -ForegroundColor Cyan
              Write-Host "  Infrastructure as Code Operation" -ForegroundColor Cyan
              Write-Host "================================================================" -ForegroundColor Cyan
              Write-Host ""
              Write-Host "Environment: $env:ServerEnvironment" -ForegroundColor Yellow
              Write-Host "Target Server: $targetServer" -ForegroundColor Yellow
              Write-Host "Operation: $env:Operation" -ForegroundColor Yellow
              Write-Host "Force Reinstall: $env:ForceReinstall" -ForegroundColor Yellow
              Write-Host ""

              # Execute operation
              switch ($env:Operation) {
                  "install-hosting-bundle" {
                      Write-Host "Installing .NET 10 Hosting Bundle on $targetServer..." -ForegroundColor Cyan
                      $forceFlag = if ($env:ForceReinstall -eq 'true') { "-Force" } else { "" }
                      
                      $scriptPath = ".\scripts\IaC\Install-DotNetHostingBundle.ps1"
                      if (-not (Test-Path $scriptPath)) {
                          Write-Error "Script not found: $scriptPath"
                          exit 1
                      }

                      & $scriptPath -ComputerName $targetServer $forceFlag
                      if ($LASTEXITCODE -ne 0) {
                          Write-Error "Hosting bundle installation failed with exit code: $LASTEXITCODE"
                          exit $LASTEXITCODE
                      }
                      Write-Host ""
                      Write-Host "[OK] .NET 10 Hosting Bundle installation completed" -ForegroundColor Green
                  }
                  "configure-gzip-compression" {
                      Write-Host "Configuring IIS Gzip Compression on $targetServer..." -ForegroundColor Cyan
                      
                      $scriptPath = ".\scripts\IaC\IISGzipConfiguration.ps1"
                      if (-not (Test-Path $scriptPath)) {
                          Write-Error "Script not found: $scriptPath"
                          exit 1
                      }

                      # Create remote session (similar to webDeploy.ps1 approach)
                      try {
                          $session = New-PSSession $targetServer
                          
                          # Copy and execute gzip configuration script on remote machine
                          Invoke-Command -Session $session -ScriptBlock {
                              # Source the script on remote machine
                              . $using:scriptPath
                              
                              # Run initialization
                              Initialize-IISGzipCompression
                              
                              # Display status
                              Write-Host ""
                              Test-IISGzipConfigurationHealth
                          }
                          
                          if ($LASTEXITCODE -ne 0) {
                              Write-Error "Gzip compression configuration failed"
                              exit 1
                          }
                          Write-Host ""
                          Write-Host "[OK] IIS Gzip Compression configuration completed" -ForegroundColor Green
                      }
                      finally {
                          Remove-PSSession -Session $session -ErrorAction SilentlyContinue
                      }
                  }
                  default {
                      Write-Error "Unknown operation: $env:Operation"
                      exit 1
                  }
              }

              Write-Host ""
              Write-Host "================================================================" -ForegroundColor Cyan
              Write-Host "[OK] IaC operation completed successfully" -ForegroundColor Green
              Write-Host "================================================================" -ForegroundColor Cyan

    profitsharing_database:
      - variables: # https://bitbucket.org/blog/predefine-values-of-custom-pipeline-variables
          - name: Environment
            default: QA
            allowed-values:
              - QA
              - UAT
          - name: Action
            default: upgrade-db
            allowed-values:
              - upgrade-db
              - drop-recreate-db
              - import-from-ready
              - import-uat-navigation
              - generate-upgrade-script
              - validate-import
              - full-reset-and-import
          - name: SourceSchema
            default: PROFITSHARE
            allowed-values:
              - PROFITSHARE
              - MTPR    
              - PROFITSHARE_STAGING
      - step:
          name: Validate SourceSchema
          script:
            - |
              if [ "$BITBUCKET_PIPELINE_OS" = "windows" ]; then
                pwsh -Command "
                  \$validSchemas = @{
                      'QA'  = @('PROFITSHARE', 'MTPR')
                      'UAT' = @('PROFITSHARE_STAGING')
                  }

                  if (-not \$validSchemas[\$env:Environment] -contains \$env:SourceSchema) {
                      Write-Host 'ERROR: Invalid SourceSchema for selected Environment'
                      Write-Host ('Allowed values for ' + \$env:Environment + ': ' + (\$validSchemas[\$env:Environment] -join ', '))
                      exit 1
                  }

                  Write-Host ('Validated: Environment=' + \$env:Environment + ', SourceSchema=' + \$env:SourceSchema)
                "
              else
                validSchemas_QA=("PROFITSHARE" "MTPR")
                validSchemas_UAT=("PROFITSHARE_STAGING")

                if [ "$Environment" = "QA" ]; then
                  validSchemas=("${validSchemas_QA[@]}")
                elif [ "$Environment" = "UAT" ]; then
                  validSchemas=("${validSchemas_UAT[@]}")
                else
                  echo "ERROR: Unknown Environment '$Environment'"
                  exit 1
                fi

                if [[ ! " ${validSchemas[@]} " =~ " $SourceSchema " ]]; then
                  echo "ERROR: Invalid SourceSchema '$SourceSchema' for Environment '$Environment'"
                  echo "Allowed values: ${validSchemas[*]}"
                  exit 1
                fi

                echo "Validated: Environment=$Environment, SourceSchema=$SourceSchema"
              fi
      - step: *upgrade-database
    playwright_e2e_qa:
      - step: *run-playwright-tests




