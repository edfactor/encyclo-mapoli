# ------------------------------------------------------------------------
# BitBucket Pipeline
# ------------------------------------------------------------------------
# Application Name:
#   - SMART Profit Sharing
# ------------------------------------------------------------------------

definitions:
  steps:
    build-and-test-backend: &build-and-test-backend
      name: Build and Test Backend API
      runs-on:
        - windows
        - self.hosted
      script:
        # Set environment variables
        - $env:NUGET_ORG = "https://api.nuget.org/v3/index.json"
        - $env:TEST_PROJECT_NAME = "Demoulas.ProfitSharing.UnitTests"
        - $env:REPORTS_PATH = "../../../../test-reports/build_${BITBUCKET_BUILD_NUMBER}"

        # Ensure the REPORTS_PATH directory exists
        - mkdir -Force -Path $env:REPORTS_PATH

        # Check if .NET 9 SDK is installed
        - echo "Checking installed .NET SDK versions..."
        - $dotnetSdkInstalled = dotnet --list-sdks | Select-String "^9\.(\d+)\.(\d+)"
        - if ($dotnetSdkInstalled) {
              $isSdkValid = $false;
              foreach ($sdk in $dotnetSdkInstalled) {
                if ($sdk -match "^9\.(\d+)\.(\d+)") {
                  $minor = [int]$matches[1];
                  $patch = [int]$matches[2];
                  if ($minor -gt 0 -or $patch -ge 306) {
                    $isSdkValid = $true;
                    break;
                  }
                }
              }
              if ($isSdkValid) {
                Write-Output ".NET SDK 9.0.306 or higher is installed.";
              } else {
                Write-Output ".NET SDK 9.0.306 or higher is NOT installed.";
                Invoke-WebRequest -Uri "https://builds.dotnet.microsoft.com/dotnet/Sdk/9.0.306/dotnet-sdk-9.0.306-win-x64.exe" -OutFile "$env:TEMP\dotnet-sdk-9.0.306-win-x64.exe";
                Start-Process -FilePath "$env:TEMP\dotnet-sdk-9.0.306-win-x64.exe" -ArgumentList "/quiet", "/norestart" -Wait;
              }
            } else {
              Write-Output "No .NET 9.x SDK installed.";
            }


        # Run tests and generate JUnit reports
        - dotnet test src/services/tests/Demoulas.ProfitSharing.UnitTests/{$env:TEST_PROJECT_NAME}.csproj --configuration Release -p:RestoreAdditionalProjectSources=$env:NUGET_ORG --test-adapter-path:. --logger:"junit;LogFilePath={$env:REPORTS_PATH}/junit.xml"

      artifacts:
        - test-reports/**
    
    test-frontend: &test-frontend
      name: Build and Test Frontend UI
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      artifacts:
        - src/ui/coverage/**
        - src/ui/FE_Tests/**
      script:
        - cd src/ui
        - echo "Running frontend tests on cloud runner..."
        
        # Update npm to latest version
        - npm install -g npm@latest
        
        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        
        # Install dependencies and run tests
        - npm ci
        - npm run test
   
    generate-buildinfo: &generate-buildinfo
      name: Generate Build Information
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - .buildinfo.json
      script:
        - dotnet tool update --global Demoulas.Common.Build.Cli --no-cache
        - Demoulas.Common.Build.Cli --buildid ${env:BITBUCKET_BUILD_NUMBER} --Branch ${env:BITBUCKET_BRANCH} --CommitHash ${env:BITBUCKET_COMMIT}
        - if (!(Test-Path ".buildinfo.json")) { Write-Error "Failed to generate .buildinfo.json"; exit 1; }
    
    create-api-artifacts: &create-api-artifacts
      name: Create API Artifacts
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        # Only update the specific tool we need, not all tools globally
        - dotnet tool update --global Demoulas.Common.Build.Cli --no-cache
        - Write-Host ${env:BITBUCKET_BUILD_NUMBER}
        - Write-Host ${env:BITBUCKET_BRANCH}
        - Write-Host ${env:BITBUCKET_COMMIT}
        - Write-Host $(Get-Location)
        - Write-Host $(Get-ChildItem)
        - New-Item -ItemType Directory -Path "dist"

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.Api -c Release -p:PublishProfile=FolderProfile -o .\publishOutput
        
        - Demoulas.Common.Build.Cli --buildid ${env:BITBUCKET_BUILD_NUMBER} --Branch ${env:BITBUCKET_BRANCH} --CommitHash ${env:BITBUCKET_COMMIT}
        - Copy-Item -Path ".buildinfo.json" -Destination ".\publishOutput\"
        
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.Api.zip -Force

    create-service-artifacts: &create-service-artifacts
      name: Create Background Service Artifacts
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        - $env:NUGET_ORG = "https://api.nuget.org/v3/index.json"
        - Write-Host $(Get-Location)
        - Write-Host $(Get-ChildItem)
        - New-Item -ItemType Directory -Path "dist"
        
        # Tool already updated in create-api-artifacts step (runs in parallel)
        # Only update if not already present
        - if (-not (Get-Command Demoulas.Common.Build.Cli -ErrorAction SilentlyContinue)) { dotnet tool update --global Demoulas.Common.Build.Cli --no-cache }

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeeFull.Sync -c Release -p:RestoreAdditionalProjectSources=$env:NUGET_ORG -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeeFull.Sync.zip -Force

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeeDelta.Sync -c Release -p:RestoreAdditionalProjectSources=$env:NUGET_ORG -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeeDelta.Sync.zip -Force

        - dotnet publish .\src\Services\src\Demoulas.ProfitSharing.EmployeePayroll.Sync -c Release -p:RestoreAdditionalProjectSources=$env:NUGET_ORG -p:PublishProfile=FolderProfile -o .\publishOutput
        - Compress-Archive -Path .\publishOutput\* -DestinationPath .\dist\Demoulas.ProfitSharing.EmployeePayroll.Sync.zip -Force

    create-frontend-artifact-qa: &create-frontend-artifact-qa
      name: Create FrontEnd Artifacts (QA)
      # Run on cloud to free on-premises resources
      image: node:22-alpine
      artifacts:
        - dist/**
      script:
        # Navigate to UI directory
        - cd src/ui
        
        # Install zip utility and update npm
        - apk add --no-cache zip
        - npm install -g npm@latest
        
        # Create .npmrc for JFrog access (using bash heredoc syntax)
        - |
          cat > .npmrc << 'EOF'
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        
        # Copy buildinfo.json from artifact to public directory
        - echo "Copying .buildinfo.json from artifact..."
        - cp ../../.buildinfo.json ./public/.buildinfo.json
        - echo "✓ Build info copied to public directory"
        - cat ./public/.buildinfo.json
        
        # Install dependencies
        - npm ci
        
        # Build for QA environment
        - npm run build:qa
        
        # Create dist directory at repo root
        - mkdir -p ../../dist
        
        # Package artifact using zip
        - cd build
        - zip -r ../../../dist/Demoulas.ProfitSharing.UI.qa.zip .
        - cd ..
        
        # Verify artifact was created
        - ls -lh ../../dist/Demoulas.ProfitSharing.UI.qa.zip
        - echo "✓ QA artifact created successfully"
        

    create-frontend-artifact-uat: &create-frontend-artifact-uat
      name: Create FrontEnd Artifacts (UAT)
      # Run on cloud to free on-premises resources
      image: node:22-alpine
      artifacts:
        - dist/**
      script:
        # Navigate to UI directory
        - cd src/ui
        
        # Install zip utility and update npm
        - apk add --no-cache zip
        - npm install -g npm@latest
        
        # Create .npmrc for JFrog access (using bash heredoc syntax)
        - |
          cat > .npmrc << 'EOF'
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        
        # Copy buildinfo.json from artifact to public directory
        - echo "Copying .buildinfo.json from artifact..."
        - cp ../../.buildinfo.json ./public/.buildinfo.json
        - echo "✓ Build info copied to public directory"
        - cat ./public/.buildinfo.json
        
        # Install dependencies
        - npm ci
        
        # Build for UAT environment
        - npm run build:uat
        
        # Create dist directory at repo root
        - mkdir -p ../../dist
        
        # Package artifact using zip
        - cd build
        - zip -r ../../../dist/Demoulas.ProfitSharing.UI.uat.zip .
        - cd ..
        
        # Verify artifact was created
        - ls -lh ../../dist/Demoulas.ProfitSharing.UI.uat.zip
        - echo "✓ UAT artifact created successfully"


    upgrade-database: &upgrade-database
      name: Upgrade Database
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dist\**
      script:
        - |
          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\output
          if ($LASTEXITCODE -ne 0) { Write-Error "Database project build failed. Exiting."; exit 1 }

          $environment = $env:Environment
          $action = $env:Action
          $sourceSchema = $env:SourceSchema
          $currentYear = $env:CurrentYear

          if (-not $environment) { $environment = "QA" }
          if (-not $action) { $action = "upgrade-db" }
          if (-not $sourceSchema) { $sourceSchema = "PROFITSHARE" }
          if (-not $currentYear) { $currentYear = "2024" }

          if ($environment -eq "QA") {
            $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_QA            
          }

          if ($environment -eq "UAT") {
            $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT            
          }

          if (-not $sourceSchema) {
            Write-Error "Source schema is undefined. Exiting."; exit 1
          }

          Write-Host "Running database upgrade with action: $action"
          Write-Host "Target environment: $environment"
          Write-Host "Source schema: $sourceSchema"
          Write-Host "Current directory: $(Get-Location)"

          # -------------------------------------------------------------
          # Full Reset & Import (Nuclear-Option parity)
          #   Action: full-reset-and-import
          #   Steps: drop-recreate-db -> import-from-ready -> import-from-navigation
          # -------------------------------------------------------------
          if ($action -eq "full-reset-and-import") {
            if ($environment -ne "QA") {
              Write-Error "Action 'full-reset-and-import' is restricted to QA environment only. Current environment: $environment"; exit 1
            }
            Write-Host "[Full Reset] Dropping & recreating schema $sourceSchema"
            .\output\Demoulas.ProfitSharing.Data.Cli drop-recreate-db --connection-name ProfitSharing --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Drop/Recreate failed. Exiting"; exit 1 }

            Write-Host "[Full Reset] Importing from READY into $sourceSchema"
            .\output\Demoulas.ProfitSharing.Data.Cli import-from-ready --connection-name ProfitSharing --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Import from READY failed. Exiting"; exit 1 }

            $navigationFile = ".\src\database\ready_import\Navigations\add-navigation-data.sql"
            if ($environment -eq "UAT") {
              $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
              Write-Host "[Full Reset] Using UAT navigation data"
            }

            Write-Host "[Full Reset] Importing navigation data from $navigationFile"
            .\output\Demoulas.ProfitSharing.Data.Cli import-from-navigation --connection-name ProfitSharing --sql-file $navigationFile --source-schema $sourceSchema
            if ($LASTEXITCODE -ne 0) { Write-Error "Navigation import failed. Exiting"; exit 1 }

            Write-Host "[Full Reset] Completed successfully."
            exit 0
          }

          .\output\Demoulas.ProfitSharing.Data.Cli $action --connection-name ProfitSharing --output-file ".\dist\migration.sql" --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $sourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Database upgrade failed. Exiting"; exit 1 }

          # Determine which navigation file to use based on action or environment
          $navigationFile = ".\src\database\ready_import\Navigations\add-navigation-data.sql"
          if ($action -eq "import-uat-navigation" -or $environment -eq "UAT") {
            $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
            Write-Host "Using UAT navigation data"
          }

          .\output\Demoulas.ProfitSharing.Data.Cli import-from-navigation  --connection-name ProfitSharing --output-file ".\dist\navigations.sql" --sql-file $navigationFile --source-schema $sourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Database upgrade failed. Exiting"; exit 1 }

          if ($action -eq "validate-import") {
            .\output\Demoulas.ProfitSharing.Data.Cli validate-import --connection-name ProfitSharing --sql-file ".\src\database\ready_import\Import Validations.sql" --source-schema $sourceSchema --current-year $currentYear
            if ($LASTEXITCODE -ne 0) { Write-Error "Database import validation failed. Exiting"; exit 1 }
          }
          

    uat-drop-recreate-db: &uat-drop-recreate-db
      name: UAT Drop & Recreate DB
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:Action = "drop-recreate-db"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          Write-Host "Dropping & recreating UAT database (schema: $env:SourceSchema)"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli $env:Action --connection-name ProfitSharing --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Drop/Recreate failed."; exit 1 }
          Write-Host "Drop & recreate completed."

    uat-import-from-ready: &uat-import-from-ready
      name: UAT Import From READY
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:Action = "import-from-ready"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          Write-Host "Importing data from READY into UAT schema: $env:SourceSchema"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli $env:Action --connection-name ProfitSharing --sql-file ".\src\database\ready_import\SQL copy all from ready to smart ps.sql" --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Import from READY failed."; exit 1 }
          Write-Host "Import from READY completed."

    uat-import-uat-navigation: &uat-import-uat-navigation
      name: UAT Import Navigation Data
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }
          $navigationFile = ".\src\database\ready_import\Navigations\add-uat-navigation-data.sql"
          Write-Host "Importing UAT navigation data using $navigationFile"
          if (!(Test-Path .\dbcli\Demoulas.ProfitSharing.Data.Cli*)) { Write-Error "DB CLI artifact not found. Ensure 'Build DB CLI (artifact)' step ran."; exit 1 }
          .\dbcli\Demoulas.ProfitSharing.Data.Cli import-from-navigation --connection-name ProfitSharing --sql-file $navigationFile --source-schema $env:SourceSchema
          if ($LASTEXITCODE -ne 0) { Write-Error "Navigation import failed."; exit 1 }
          Write-Host "Navigation import completed."

    uat-validate-import: &uat-validate-import
      name: UAT Validate Import
      runs-on:
        - windows
        - self.hosted
      script:
        - |
          $env:Environment = "UAT"
          $env:SourceSchema = "PROFITSHARE_STAGING"
          $currentYear = (Get-Date).Year

          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\output
          if ($LASTEXITCODE -ne 0) { Write-Error "Database project build failed. Exiting."; exit 1 }

          if ($env:Environment -eq "UAT") { $env:ConnectionStrings:ProfitSharing = $env:ConnectionStrings_ProfitSharing_UAT }

          Write-Host "Validating UAT import for schema $env:SourceSchema and year $currentYear"
          .\output\Demoulas.ProfitSharing.Data.Cli validate-import --connection-name ProfitSharing --sql-file ".\src\database\ready_import\Import Validations.sql" --source-schema $env:SourceSchema --current-year $currentYear
          if ($LASTEXITCODE -ne 0) { Write-Error "Import validation failed."; exit 1 }
          Write-Host "Import validation completed."

    db-cli-build-artifact: &db-cli-build-artifact
      name: Build DB CLI (artifact)
      runs-on:
        - windows
        - self.hosted
      artifacts:
        - dbcli/**
      script:
        - |
          dotnet build .\src\services\src\Demoulas.ProfitSharing.Data.Cli\Demoulas.ProfitSharing.Data.Cli.csproj -o .\dbcli
          if ($LASTEXITCODE -ne 0) { Write-Error "Database CLI build failed. Exiting."; exit 1 }
          Write-Host "DB CLI built to .\\dbcli"

    audit-backend: &audit-backend
      name: "Check Backend API for vulnerabilities"
      runs-on:
        - windows
        - self.hosted
      script:
        - $env:SolutionDir = ".\src\services"
        - echo "Checking dotnet vulnerabilities"
        - cd $env:SolutionDir

        - dotnet --info
        - dotnet nuget list source
        - dotnet workload update --source https://api.nuget.org/v3/index.json
        - dotnet workload install aspire --source https://api.nuget.org/v3/index.json
        - dotnet restore Demoulas.ProfitSharing.slnx -p:RestoreAdditionalProjectSources=https://api.nuget.org/v3/index.json


        - |
          $output = dotnet list Demoulas.ProfitSharing.slnx package --vulnerable --include-transitive --source https://api.nuget.org/v3/index.json
          if ($output -match "has the following vulnerable packages") {
            Write-Host "Vulnerabilities found!"
            Write-Host $output
            exit 1
          } else {
            Write-Host "No vulnerabilities found."
            exit 0
          }        


    audit-frontend: &audit-frontend
      name: "Check frontend for vulnerabilities"
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      script:
        - cd src/ui
        - echo "Checking npm vulnerabilities on cloud runner..."
        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF
        - npm audit --audit-level=high --production
    
    frontend-lint: &frontend-lint
      name: Frontend Lint
      # Run on Bitbucket Cloud to free on-premises resources
      image: node:22-alpine
      max-time: 10
      script:
        - cd src/ui
        - echo "Running frontend linting on cloud runner..."

        # Update npm to latest version
        - npm install -g npm@latest

        # Create .npmrc for JFrog access (uses pipeline variable)
        - |
          cat > .npmrc << EOF
          registry=https://demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/
          //demoulas.jfrog.io/artifactory/api/npm/demoulas-npm-virt/:_authToken=${JFROG_WORKSPACE_VARIABLE}
          EOF

        # Install dependencies and run linting
        - npm ci
        - npm run lint

    secret-scan: &secret-scan
      name: "Secret scan (Gitleaks)"
      # Runs on Bitbucket Cloud by default (Docker image)
      image: zricethezav/gitleaks:latest
      max-time: 5
      artifacts:
        - reports/**
      script:
        - mkdir -p reports
        - gitleaks detect --source . --config gitleaks.toml --redact --no-banner --report-format json --report-path reports/gitleaks.json --exit-code 0
        - echo "Gitleaks findings (redacted JSON):"
        - head -c 200000 reports/gitleaks.json || true
        - |
          # Robust leak evaluation without python dependency
          if [ ! -s reports/gitleaks.json ]; then
            echo "No leaks found (empty report).";
          else
            if command -v jq >/dev/null 2>&1; then
              findings_count=$(jq 'if type=="array" then length elif (.findings|type? == "array") then (.findings|length) else 0 end' reports/gitleaks.json 2>/dev/null || echo 0)
            else
              # Fallback: treat literal [] or [ ] as zero, anything else non-empty as 1
              if grep -q '"Description"' reports/gitleaks.json; then
                # Some formats include fields; attempt crude count of occurrences of "RuleID"
                findings_count=$(grep -o '"RuleID"' reports/gitleaks.json | wc -l | tr -d ' ')
              elif grep -Eq '^\s*\[\s*\]\s*$' reports/gitleaks.json; then
                findings_count=0
              else
                # Non-empty & not literal empty array: assume at least 1
                findings_count=1
              fi
            fi
            echo "Gitleaks findings count: $findings_count"
            if [ "${findings_count}" -gt 0 ]; then
              echo "Leaks found. Failing the build.";
              exit 1;
            else
              echo "No leaks found.";
            fi
          fi
    run-playwright-tests: &run-playwright-tests
      name: "Run Playwright E2E Tests (QA)"
      runs-on:
        - windows
        - self.hosted
        - volta
      artifacts:
        - ui/playwright-report/**
        - ui/test-results/**
        - src/UI/playwright-report/**
        - src/UI/test-results/**
        - playwright-artifacts/**
      script:
        - |
          <#
            Playwright E2E Runner (QA)
            Sections:
              1) Locate project dir
              2) Ensure Node version (Volta)
              3) Materialize .env from QA_Playwright variable
              4) Install deps & browsers
              5) Execute tests (JUnit + HTML)
              6) Collect artifacts & set exit code
          #>

          Write-Host "[1] Locate Playwright project directory" -ForegroundColor Cyan
          $candidateDirs = @('ui','src/UI','src/ui')
          $playwrightDir = $candidateDirs | Where-Object { Test-Path $_ } | Select-Object -First 1
          if (-not $playwrightDir) { Write-Error "Playwright project directory not found. Checked: $($candidateDirs -join ', ')"; exit 1 }
          Set-Location $playwrightDir
          Write-Host "Using directory: $playwrightDir"

          Write-Host "[2] Ensure compatible Node.js version" -ForegroundColor Cyan
          $targetNode = '22.16.0'
          try { $currentNode = (node -v) 2>$null } catch { $currentNode = 'unknown' }
          Write-Host "Current node: $currentNode"
          if (Get-Command volta -ErrorAction SilentlyContinue) {
            volta install node@$targetNode | Out-Null
            Write-Host "Node after install: $(node -v)"
          } else {
            Write-Host "Volta unavailable; proceeding with existing Node version" -ForegroundColor Yellow
          }

          Write-Host "[3] Build .env from QA_Playwright variable" -ForegroundColor Cyan
          if (-not $env:QA_Playwright) { Write-Error "QA_Playwright variable not set"; exit 1 }
          $raw = $env:QA_Playwright
          # Tokenize by whitespace; handle patterns like KEY=value and KEY= value
          $parts = $raw -split '\s+' | Where-Object { $_ -and ($_ -notmatch '^\s*$') }
          $kv = @{}
          for ($i = 0; $i -lt $parts.Length; $i++) {
            $p = $parts[$i]
            if ($p -match '^([A-Za-z_][A-Za-z0-9_]*)=(.*)$') {
              $k = $matches[1]
              $v = $matches[2]
              if ($v -eq '') {
                # Value may be next token (e.g. USER_NAME= rharding)
                if ($i + 1 -lt $parts.Length -and ($parts[$i+1] -notmatch '^[A-Za-z_][A-Za-z0-9_]*=')) {
                  $v = $parts[$i+1]
                  $i++
                }
              }
              $v = $v.Trim().Trim('"').Trim("'")
              if (-not $kv.ContainsKey($k)) { $kv[$k] = $v }
            }
          }
          $userKey = ($kv.Keys | Where-Object { $_ -in 'USER_NAME','USERNAME','USER','LOGIN' } | Select-Object -First 1)
          $passKey = ($kv.Keys | Where-Object { $_ -in 'PASSWORD','PASS','PWD' } | Select-Object -First 1)
          $userVal = if ($userKey) { $kv[$userKey] } else { '' }
          $passVal = if ($passKey) { $kv[$passKey] } else { '' }
          $ciVal = if ($kv.ContainsKey('CI')) { $kv['CI'] } else { '' }
          $qaVal = if ($kv.ContainsKey('QA')) { $kv['QA'] } else { '' }
          if (-not $userVal -or -not $passVal) {
            Write-Host 'Parsed keys (no secrets): ' + ($kv.Keys -join ', ')
            Write-Error 'Missing USER credential (USER_NAME/USERNAME/USER/LOGIN) and/or PASSWORD (PASSWORD/PASS/PWD) in QA_Playwright value.'; exit 1
          }
          $lines = @(
            "CI=$ciVal",
            "QA=$qaVal",
            "USER_NAME=$userVal",
            "PASSWORD=$passVal"
          )
          Set-Content ./.env -Value $lines
          Write-Host ".env keys emitted: CI, QA, USER_NAME, PASSWORD"
          # Some configs expect a .playwright.env specifically; create it if not present
          Copy-Item ./.env ./.playwright.env -Force

          Write-Host "[4] Install dependencies & browsers" -ForegroundColor Cyan
          if (Test-Path node_modules) { Remove-Item -Recurse -Force node_modules }
          npm ci
          npx playwright install --with-deps; if ($LASTEXITCODE -ne 0) { npx playwright install }

          Write-Host "[5] Run tests" -ForegroundColor Cyan
          New-Item -ItemType Directory -Path test-results -Force | Out-Null

          # Diagnostic: show any duplicate playwright test packages
          Get-ChildItem -Path node_modules -Filter playwright -Recurse -Depth 3 -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object { Write-Host "Found playwright path: $($_.FullName)" }
          Get-ChildItem -Path node_modules -Filter "@playwright" -Recurse -Depth 5 -ErrorAction SilentlyContinue | Select-Object -First 5 | ForEach-Object { Write-Host "Found @playwright path: $($_.FullName)" }
          # Use direct CLI to avoid potential global 'playwright' package ambiguity
          $playwrightCli = Join-Path (Resolve-Path ./node_modules/@playwright/test).Path "cli.js"
          if (-not (Test-Path $playwrightCli)) { Write-Error "Playwright CLI not found at $playwrightCli"; Get-ChildItem node_modules/@playwright/test -Recurse -Depth 2; exit 1 }
          node $playwrightCli test --reporter "list,junit" --config=playwright.config.ts --output=test-results --workers=1
          $pwExit = $LASTEXITCODE

          Write-Host "[6] Prepare Bitbucket test-reports ingestion" -ForegroundColor Cyan
          $repoRoot = $env:BITBUCKET_CLONE_DIR; if (-not $repoRoot) { $repoRoot = (Resolve-Path '..').Path }
          $bbTestRoot = Join-Path $repoRoot 'test-reports'
          $bbPlaywrightDir = Join-Path $bbTestRoot 'playwright'
          if (!(Test-Path $bbPlaywrightDir)) { New-Item -ItemType Directory -Path $bbPlaywrightDir -Force | Out-Null }
          # Locate a junit xml (reporter names can vary). Prefer explicit junit.xml if present.
          $junitCandidate = @(
            Get-ChildItem -Path test-results -Recurse -Filter junit*.xml -ErrorAction SilentlyContinue
            Get-ChildItem -Path test-results -Recurse -Filter *.xml -ErrorAction SilentlyContinue | Where-Object { (Get-Content $_.FullName -TotalCount 5) -match '<testsuite' }
          ) | Where-Object { $_ } | Select-Object -First 1
          if ($junitCandidate) {
            Copy-Item $junitCandidate.FullName (Join-Path $bbPlaywrightDir 'junit.xml') -Force
            Write-Host "Copied JUnit report to test-reports/playwright/junit.xml"
          } else {
            Write-Host "No JUnit XML found to copy." -ForegroundColor Yellow
          }

          Write-Host "[7] Collect artifacts" -ForegroundColor Cyan
          $artifactRoot = Join-Path $repoRoot 'playwright-artifacts'
            if (!(Test-Path $artifactRoot)) { New-Item -ItemType Directory -Path $artifactRoot | Out-Null }
          foreach ($d in 'playwright-report','test-results') { if (Test-Path $d) { Copy-Item -Recurse -Force $d (Join-Path $artifactRoot $d) } }

          Write-Host "[8] Finalize with exit code $pwExit" -ForegroundColor Cyan
          exit $pwExit
          

pipelines:
  branches:
    release:
      # Stage 1: Build and test
      - parallel:
          - step: *build-and-test-backend
          - step: *test-frontend
          - step: *audit-frontend
          - step: *audit-backend
      # Stage 2: Generate build information (Windows, ~30 seconds)
      - step: *generate-buildinfo
      # Stage 3: Create artifacts (API/services on Windows, UI builds in parallel on cloud)
      - parallel:
          - step: *create-api-artifacts
          - step: *create-service-artifacts
          - step: *create-frontend-artifact-qa
          - step: *db-cli-build-artifact
      # Stage 4: QA Deployment
      - step:
          name: "Application Deployment (QA)"
          runs-on:
            - windows
            - self.hosted
          deployment: QA
          trigger: "manual"
          script:
            - $env:ENV = "QA"
            - $env:API_SERVER_QA = "appt23d"
            - pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/EmployeeDelta'
            - pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/EmployeeFull'
            - pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/NextGenApplications/ps/Payroll'
            - pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.qa.json' -RemoteServer $env:API_SERVER_QA -RemotePath 'C:/inetpub/wwwroot/api'
            - echo "Deploying web application..."
            # Reuse the same API artifact built once in Stage 2
            - $env:API_ARTIFACT_NAME = "Demoulas.ProfitSharing.Api.zip"
            - $env:UI_ARTIFACT_NAME = "Demoulas.ProfitSharing.UI.QA.zip"
            - pwsh .\scripts\webDeploy.ps1 $env:ENV $env:API_SERVER_QA $env:API_ARTIFACT_NAME $env:UI_ARTIFACT_NAME
            - echo "Deploying background service..."
            - pwsh .\scripts\servicesDeploy.ps1 ${env:ENV} $env:API_SERVER_QA
      - step: *upgrade-database
  
      - step:
          name: "Checking API Health"
          runs-on:
            - windows
            - self.hosted
          script:
            - $env:API_SERVER_QA = "appt23d"
            - pwsh -File ./scripts/Check-Health.ps1 -Url $env:QA_BASE_URL -envServerName $env:API_SERVER_QA

      # Stage 4: UAT Promotion Gate
      - step:
          name: "Gate: Promote to UAT"
          runs-on:
            - windows
            - self.hosted
          trigger: "manual"
          script:
            - echo "Manual approval granted. Continuing to UAT deployment & data operations."
            - |
              Write-Host "Release context:"
              Write-Host ("  Build: " + $env:BITBUCKET_BUILD_NUMBER)
              Write-Host ("  Branch: " + $env:BITBUCKET_BRANCH)
              Write-Host ("  Commit: " + $env:BITBUCKET_COMMIT)
              Write-Host ("  QA API: " + $env:QA_BASE_URL)
              Write-Host "Artifacts in ./dist:"
              if (Test-Path .\dist) {
                Get-ChildItem -Recurse -File .\dist | ForEach-Object {
                  "{0,10} bytes  {1}" -f $_.Length, $_.FullName
                }
              } else {
                Write-Host "  (no dist folder found)"
              }
              Write-Host "Planned UAT sequence:"
              Write-Host "  1) Drop & Recreate DB (parallel with app deploy)"
              Write-Host "  2) App deploy + Import from READY (reusing artifacts from Stage 3)"
              Write-Host "  3) Import UAT navigation"
              Write-Host "  4) Parallel: Validate import + UAT API health check"

      - step: *create-frontend-artifact-uat
      # Stage 5: UAT Deployment (reuses artifacts from Stage 3)
      - parallel:
          - step: *uat-drop-recreate-db
          - step:
              name: "Application Deployment UAT"
              runs-on:
                - windows
                - self.hosted
              deployment: UAT
              script:
                - echo "Deploying application to UAT (reusing API artifact from Stage 2)..."
                - $env:API_SERVER_UAT = "appt24d"
                - $env:ENV = "UAT"
                - pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/EmployeeDelta'
                - pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/EmployeeFull'
                - pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/NextGenApplications/ps/Payroll'
                - pwsh -File ./scripts/credsettings.ps1 -Environment ${env:ENV} -FilePath './src/services/configuration/credsettings.json' -OutputPath './src/services/configuration/credsettings.uat.json' -RemoteServer $env:API_SERVER_UAT -RemotePath 'C:/inetpub/wwwroot/api'
                - echo "Deploying web application..."
                # Reuse the same API artifact built once in Stage 2
                - $env:API_ARTIFACT_NAME = "Demoulas.ProfitSharing.Api.zip"
                - $env:UI_ARTIFACT_NAME = "Demoulas.ProfitSharing.UI.UAT.zip"
                - pwsh .\scripts\webDeploy.ps1 $env:ENV $env:API_SERVER_UAT $env:API_ARTIFACT_NAME $env:UI_ARTIFACT_NAME
                - echo "Deploying background service..."
                - pwsh .\scripts\servicesDeploy.ps1 ${env:ENV} $env:API_SERVER_UAT
      # Stage 6: UAT Database Import (must run AFTER drop-recreate completes)
      - step: *uat-import-from-ready
      - step: *uat-import-uat-navigation
      - parallel:
          - step: *uat-validate-import
          - step:
              name: "Checking API Health (UAT)"
              runs-on:
                - windows
                - self.hosted
              script:
                - $env:API_SERVER_UAT = "appt24d"
                - pwsh -File ./scripts/Check-Health.ps1 -Url $env:UAT_BASE_URL -envServerName $env:API_SERVER_UAT


    develop:
      - parallel:
          - step: *build-and-test-backend
          - step: *test-frontend
          - step: *audit-frontend
          - step: *audit-backend


  pull-requests:
    '**':
      # Stage 1: Code quality checks (fail fast)
      - step: *frontend-lint
      # Stage 2: Build and test
      - parallel:
          - step: *build-and-test-backend
          - step: *test-frontend
      # Stage 3: Run audits and security scans only if build succeeds
      - parallel:
          - step: *audit-frontend
          - step: *audit-backend
          - step: *secret-scan
  
  custom:
    profitsharing_database:
      - variables: # https://bitbucket.org/blog/predefine-values-of-custom-pipeline-variables
          - name: Environment
            default: QA
            allowed-values:
              - QA
              - UAT
          - name: Action
            default: upgrade-db
            allowed-values:
              - upgrade-db
              - drop-recreate-db
              - import-from-ready
              - import-uat-navigation
              - generate-upgrade-script
              - validate-import
              - full-reset-and-import
          - name: SourceSchema
            default: PROFITSHARE
            allowed-values:
              - PROFITSHARE
              - MTPR    
              - PROFITSHARE_STAGING
      - step:
          name: Validate SourceSchema
          script:
            - |
              if [ "$BITBUCKET_PIPELINE_OS" = "windows" ]; then
                pwsh -Command "
                  \$validSchemas = @{
                      'QA'  = @('PROFITSHARE', 'MTPR')
                      'UAT' = @('PROFITSHARE_STAGING')
                  }

                  if (-not \$validSchemas[\$env:Environment] -contains \$env:SourceSchema) {
                      Write-Host 'ERROR: Invalid SourceSchema for selected Environment'
                      Write-Host ('Allowed values for ' + \$env:Environment + ': ' + (\$validSchemas[\$env:Environment] -join ', '))
                      exit 1
                  }

                  Write-Host ('Validated: Environment=' + \$env:Environment + ', SourceSchema=' + \$env:SourceSchema)
                "
              else
                validSchemas_QA=("PROFITSHARE" "MTPR")
                validSchemas_UAT=("PROFITSHARE_STAGING")

                if [ "$Environment" = "QA" ]; then
                  validSchemas=("${validSchemas_QA[@]}")
                elif [ "$Environment" = "UAT" ]; then
                  validSchemas=("${validSchemas_UAT[@]}")
                else
                  echo "ERROR: Unknown Environment '$Environment'"
                  exit 1
                fi

                if [[ ! " ${validSchemas[@]} " =~ " $SourceSchema " ]]; then
                  echo "ERROR: Invalid SourceSchema '$SourceSchema' for Environment '$Environment'"
                  echo "Allowed values: ${validSchemas[*]}"
                  exit 1
                fi

                echo "Validated: Environment=$Environment, SourceSchema=$SourceSchema"
              fi
      - step: *upgrade-database
    playwright_e2e_qa:
      - step: *run-playwright-tests




